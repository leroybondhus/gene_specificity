---
title: "specificity_paper_main"
author: "Leroy Bondhus"
date: "8/19/2021"
output: html_document
---


## NOTE: most functions live in GeneSpecificityFuncs package for 
##       this project. Load this package here
## 
```{r set up package of functions used}
library("devtools")
library("roxygen2")
install("./../GeneSpecificityFuncs")
```

## load gtex here
```{r import dataset}
## import gtex medians data
temp <- tempfile()
download.file("https://storage.googleapis.com/gtex_analysis_v8/rna_seq_data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz",temp)
gtex <- read.table( temp, skip=2, header = TRUE, sep = "\t")
unlink(temp); rm(temp)



library(biomaRt)
## import ensembl gene data
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
genes <- getBM(attributes=c('chromosome_name','start_position','end_position','hgnc_symbol', 'ensembl_gene_id','gene_biotype'),
                 filters = list('biotype'='protein_coding'),
                 mart = ensembl, useCache = F) 
genes <- genes[which(is.element(genes$chromosome_name, c(1:22, "X", "Y", "MT")) & genes$hgnc_symbol != "" ) ,]



```

## clean gtex dataset here
```{r clean dataset}
## show mitochondrial genes drive a large part of sample similarity
## Note sum of medians in gtex not quite 1M - likely artifact of taking medians
barplot(colSums(gtex[,3:ncol(gtex)]))
which <- which(genes$chromosome_name != "MT" )
whichMT <- which(genes$chromosome_name == "MT" )
library(stringr)
## match genes between gtex and ensembl
gtex_names <- str_split_fixed(gtex$Name, "[.]", 2)[,1]
gtex_cleaned <- gtex[which(is.element(gtex_names, genes$ensembl_gene_id[which])),]
gtex_cleanedMT <- gtex[which(is.element(gtex_names, genes$ensembl_gene_id[whichMT])),]

##non-mitochondrial TPM sum
barplot(colSums(gtex_cleaned[,3:ncol(gtex_cleaned)]))
##mitochondrial TPM sum
barplot(colSums(gtex_cleanedMT[,3:ncol(gtex_cleanedMT)]))
## non-mito + mito TPM sum
barplot(colSums(gtex_cleaned[,3:ncol(gtex_cleaned)])+colSums(gtex_cleanedMT[,3:ncol(gtex_cleanedMT)]))

##renormalize TPM without mitochondrial genes
gtex_cleaned_renorm <- gtex_cleaned
for(i in 3:ncol(gtex_cleaned_renorm)){
  gtex_cleaned_renorm[,i] <- (gtex_cleaned_renorm[,i]*1e6 / sum(gtex_cleaned_renorm[,i]))
}
barplot(colSums(gtex_cleaned_renorm[,3:ncol(gtex_cleaned_renorm)]))

#### Supplemental Figure (Fraction of TPM from chr==M )
gtex <- gtex_cleaned_renorm
#### Supplemental Figure (heatmap cluster of samples )

## remove mitochondrial contribution
```


```{r measure sample similarity}
### to do: justify method for measuring sample similarity - may require comparison or refs
make_zscore_matrix<- function(dat) {
  zscores <- matrix(NA, nrow = nrow(dat), ncol = ncol(dat))
  means <- rowMeans(dat)
  sds <- as.numeric(rep(NA,length(means)))
  which <- which(means != 0)
  sds[which] <- apply(dat[which,],1,sd)
  for(j in 1:ncol(dat)){zscores[,j] <- (dat[,j] - means)/sds  }
  return(zscores)
}

make_dot_product_similarity_matrix <- function(dat) {
  dot_product_similarity_matrix <- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)){
      which_i <- which(!is.na(dat[,i])) ## ignore NAs
      which_j <- which(!is.na(dat[,j])) ## ignore NAs
      dot_product_similarity_matrix[i,j] <- sum(dat[which_i,i] * dat[which_j,j]) / (norm(dat[which_i,i],"2")*norm(dat[which_j,j],"2"))
    }
  }
  return(dot_product_similarity_matrix)
}

zscores <- make_zscore_matrix(log10(gtex[,3:ncol(gtex)]+1) )
dot_sim <- make_dot_product_similarity_matrix(zscores)

colnames(dot_sim) <- colnames(gtex[,3:ncol(gtex)])
rownames(dot_sim) <- colnames(gtex[,3:ncol(gtex)])

### validate choice
##use dist=1-dot_sim(zscores(log10(tpm+1))), single linkage clustering for now 
plot(hclust(as.dist(1-dot_sim),method = "single"), hang = -1, main = "dot_sim,single_clust")
sim_mat <- dot_sim
### create: sim_mat # sample similarity matrix
```


```{r hierarchical clustering on sample similarity}
### to do: justify method for hierarchical clustering - may require comparison or refs

GeneSpecificityFuncs::LMB_htf.dist_tree()

sim_tree <- as.dendrogram(hclust(as.dist(1-dot_sim),method = "single"))
str(unclass(sim_tree))

attributes(sim_tree[[1]]) <- c(attributes(sim_tree[[1]]), tempy="hello_from_tempy")

attributes(sim_tree)


LMB_dend.add_dist_to_parent <- function(dend, dist_to_parent=0){
  ## note: distance to parent is fed in at the start of the function
  attributes(dend) <- c(attributes(dend), dist_to_parent=dist_to_parent)
  ## test if at leaf node
  if(!is.null(attributes(dend)$leaf) && attributes(dend)$leaf){
    return(dend)
  }
  for(i in 1:length(dend)){ ## length of dend should be number of child nodes
    ## distance to parent is simply the difference in height between parent and child
    dist_to_parent <- attributes(dend)$height - attributes(dend[[i]])$height 
    dend[[i]] <- LMB_dend.add_dist_to_parent(dend[[i]], 
                                             dist_to_parent = dist_to_parent)
  }
  return(dend)
}
sim_tree <- LMB_dend.add_dist_to_parent(sim_tree)

LMB_dend.add_weights <- function(dend){
  num_desc <- attributes(dend)$members
  weight <- 
  attributes(dend)<- c(attributes(dend), weight=weight)
}

## yenifer's code
##dend has this already :) 
count_number_descendant<- function(node) {
  if(is.na(node$left_child) & is.na(node$right_child)){
    return(1) }
  else{
   return (count_number_descendant(node$left_child)+count_number_descendant(node$right_child))}
}
calc_node_weight <- function(node, parent_weight = 0) {
node$weight <-  (node$dist_to_parent / count_number_descendant(node)) + parent_weight
	if(!all(is.na(node[["left_child"]]))){
	  	 node[["left_child"]]<-calc_node_weight(node[["left_child"]],parent_weight = node$weight)
       node[["right_child"]]<-calc_node_weight(node[["right_child"]],parent_weight = node$weight)
	}
return(node)
}

 return_sample_weights <- function(node){
   if(is.na(node$left_child) & is.na(node$right_child)){
     return(data.frame(name = node$name,weight = node$weight))
   }
 return(rbind(return_sample_weights(node[["left_child"]]),return_sample_weights(node[["right_child"]])))
}
### create: sim_tree # sample similarity tree
```


```{r calculate sample weights}
### uses Equation 1. 

### create: sample_weights
```


```{r calculate specificity}
### uses Equation 2.

### creates: spec_mat # specificity matrix
```





```{r validation with variable sample set}


```



