---
title: "specificity_paper_main"
author: "Leroy Bondhus"
date: "8/19/2021"
output: html_document
---

```{r libraries}
library(ggplot2)
library(ggpubr)
library(biomaRt)
library(stringr)
library(dendextend)
library(dplyr)
library(Hmisc)
library(doParallel)
library(foreach)
registerDoParallel(detectCores()-1)
library(ComplexHeatmap)
library(circlize)
library(scales)
library(reldist)
library(gridExtra)
```

## load gtex here
```{r import dataset}
## import gtex medians data
temp <- tempfile()
download.file("https://storage.googleapis.com/gtex_analysis_v8/rna_seq_data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz",temp)
gtex <- read.table( temp, skip=2, header = TRUE, sep = "\t")
gtex_rowinfo <- data.frame(Name=gtex$Name, Description=gtex$Description)
rownames(gtex) <- gtex$Name
gtex <- as.matrix(gtex[,3:ncol(gtex)])
unlink(temp); rm(temp)


## import ensembl gene data
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
genes <- getBM(attributes=c('chromosome_name','start_position','end_position','hgnc_symbol', 'ensembl_gene_id','gene_biotype'),
                 filters = list('biotype'='protein_coding'),
                 mart = ensembl, useCache = F) 
genes <- genes[which(is.element(genes$chromosome_name, c(1:22, "X", "Y", "MT")) & genes$hgnc_symbol != "" ) ,]
```

## clean gtex dataset here
```{r clean dataset}
## show mitochondrial genes drive a large part of sample similarity
## Note sum of medians in gtex not quite 1M - likely artifact of taking medians
barplot(colSums(gtex))

## match genes between gtex and ensembl
gtex_names <- str_split_fixed(gtex_rowinfo$Name, "[.]", 2)[,1]
which <- which(genes$chromosome_name != "MT" )
gtex_cleaned <- gtex[which(is.element(gtex_names, genes$ensembl_gene_id[which])),]
which <- which(genes$chromosome_name == "MT" )
gtex_cleanedMT <- gtex[which(is.element(gtex_names, genes$ensembl_gene_id[which])),]

barplot(colSums(gtex_cleaned))     ##non-mitochondrial TPM sum
barplot(colSums(gtex_cleanedMT))   ##mitochondrial TPM sum
rm(gtex_cleanedMT)
##renormalize TPM without mitochondrial genes
for(i in 1:ncol(gtex_cleaned)){
  gtex_cleaned[,i] <- (gtex_cleaned[,i]*1e6 / sum(gtex_cleaned[,i]))
}
barplot(colSums(gtex_cleaned))

gtex <- gtex_cleaned; rm(gtex_cleaned)
exp_mat <- gtex
## log10(TPM+1) transform of data
exp_mat <- log10(exp_mat+1)

## remove mitochondrial contribution
```
```{r collected functions used }

calc_zscore_matrix<- function(dat) {
  zscores <- dat; zscores[] <- 0 
  means <- rowMeans(dat)
  sds <- as.numeric(rep(NA,length(means)))
  which <- which(means != 0)
  sds[which] <- apply(dat[which,],1,sd)
  for(j in 1:ncol(dat)){zscores[,j] <- (dat[,j] - means)/sds  }
  return(zscores)
}

calc_dot_product_similarity_matrix <- function(dat) {
  dot_product_similarity_matrix <- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  colnames(dot_product_similarity_matrix) <- colnames(dat)
  rownames(dot_product_similarity_matrix) <- colnames(dat)
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)){
      which_i <- which(!is.na(dat[,i])) ## ignore NAs
      which_j <- which(!is.na(dat[,j])) ## ignore NAs
      dot_product_similarity_matrix[i,j] <- sum(dat[which_i,i] * dat[which_j,j]) / (norm(dat[which_i,i],"2")*norm(dat[which_j,j],"2"))
    }
  }
  return(dot_product_similarity_matrix)
}

### uses Equation 1. 
## modelled on Yenifer's code
add_dist_to_parent <- function(dend, dist_to_parent=0){
  ## note: distance to parent is fed in at the start of the function
  attributes(dend) <- c(attributes(dend), dist_to_parent=dist_to_parent)
  ## test if at leaf node
  if(!is.null(attributes(dend)$leaf) && attributes(dend)$leaf){
    return(dend)
  }
  for(i in 1:length(dend)){ ## length of dend should be number of child nodes
    ## distance to parent is simply the difference in height between parent and child
    dist_to_parent <- attributes(dend)$height - attributes(dend[[i]])$height 
    dend[[i]] <- add_dist_to_parent(dend[[i]], 
                                             dist_to_parent = dist_to_parent)
  }
  return(dend)
}

## this functions calculates and adds weights to dendrogram object using the 'dist_to_parent' attribute added previously
## weight_of_parent parameter exists only for recursion and should not be manually adjusted without understanding it's function
add_weights <- function(dend, weight_of_parent=0){
  weight <- (attributes(dend)$dist_to_parent / attributes(dend)$members) + weight_of_parent 
  attributes(dend) <- c(attributes(dend), weight=weight)
  ## test if at leaf node
  if(!is.null(attributes(dend)$leaf) && attributes(dend)$leaf){
    return(dend)
  }
  for(i in 1:length(dend)){ ## length of dend should be number of child nodes
    dend[[i]] <- add_weights(dend[[i]], weight_of_parent=weight)
  }
  return(dend)
}

## this function returns the weights from a dendrogram object that has a "weight" attribute at leaves. Also requires the order of the vector to return based on names of leaves
get_weights <- function(dend, name_order){
  weights <- setNames(get_leaves_attr(dend,"weight"),nm=get_leaves_attr(dend,"lab") )
  weights <- weights[order(factor(names(weights),levels = name_order))]
  return(weights)
}


# function to calculate weighted zscores given matrix and vector of weights. column names of the matrix and names of the weight vector must match
calc_weighted_zscore_matrix <- function(mat, weights){
  if(any( colnames(mat) != names(weights) )){stop("WARNING: mismatch in weights names and matrix colnames order")}
  weighted_mat <- mat; weighted_mat[] <- 0
  for (i in 1:length(weights)){
    weighted_mat[,i] <- weights[i]*mat[,i]
  }
  weighted_means <- numeric(length = nrow(weighted_mat))
  sum_of_weights <- sum(weights)
  for (i in 1:nrow(weighted_mat)){
    weighted_means[i] <- sum(weighted_mat[i,]) / sum_of_weights
  }
  weighted_var <- numeric(length=nrow(mat))
  for (i in 1:nrow(mat)){
    weighted_var[i] <- Hmisc::wtd.var(mat[i,],weights=weights)
  }
  weighted_sd <- sqrt(weighted_var)
  for(i in 1:ncol(mat)){
    mat[,i] <- (mat[,i]-weighted_means)/weighted_sd
  }
  weighted_zscores <- mat
  return(weighted_zscores)
}



# weighted tau
calc_weighted_tau <- function(te_matrix, weights_vector){
  xhat_matrix <- matrix(nrow=nrow(te_matrix),ncol=ncol(te_matrix))
  te_row_maxima <- apply(te_matrix, 1, max)
  for(j in 1:ncol(te_matrix)){
    xhat_matrix[,j] <- te_matrix[,j] / te_row_maxima
  }
  temp_matrix <- matrix(nrow=nrow(te_matrix),ncol=ncol(te_matrix))
  for (i in 1:nrow(te_matrix)){
    temp_matrix[i,] <- weights_vector - (xhat_matrix[i,] * weights_vector)
  }
  tau <- c()
  den <- sum(weights_vector) - 1
  for (i in 1:nrow(temp_matrix)){
    temp <- sum(temp_matrix[i,]) / den
    tau <- append(tau,temp)
  }
  ## add normalization (believe this is a numeric instability issue from dividing small numbers)
  # tau <- tau / max(tau, na.rm=T)
  ## alternative, set all > 1 to 1 (when looking at plots for different cutoffs, normalizing true 1 values causes issue)
  tau[which(tau > 1)] <- 1
  return(tau)
}

calc_weighted_tsi <- function(te_matrix,weights_vector){
  tsi <- c()
  weights_vector <- as.matrix(weights_vector)
  weighted_matrix <- matrix(nrow=nrow(te_matrix),ncol=ncol(te_matrix))
  for (m in 1:nrow(weights_vector)){
    weighted_matrix[,m] <- weights_vector[m,1]*te_matrix[,m]
  }
  for (i in 1:nrow(te_matrix)){
    num <- max(weighted_matrix[i,])
    den <- sum(weighted_matrix[i,])
    temp <- num/den
    tsi <- append(tsi,temp)
  }
  return(tsi)
}

calc_weighted_gini <- function(te_matrix, weights_vector){
   gini_values <-  c()
  for (i in 1:nrow(te_matrix)){
    temp <- as.numeric(te_matrix[i,])
    temp <- reldist::gini(temp, weights_vector)
    gini_values <- append(gini_values,temp)
  }
  return(gini_values)
}


```

```{r organizing functions into lists}
### generalizing a list to store results in - this will make it easier to extend later if necessary.
## Note: only need the weighted version of each equation as each simplifies to flat version when all weights are 1
specificity_measures <- list(func_names=c("Zscore", "Tau", "Tsi","Gini"),
                             funcs=list(Zscore=calc_weighted_zscore_matrix,
                                        Tau=calc_weighted_tau,
                                        Tsi=calc_weighted_tsi,
                                        Gini=calc_weighted_gini),
                             out_type=list(Zscore="matrix",
                                           Tau="vector",
                                           Tsi="vector",
                                           Gini="vector")
                             )
## only 1 similarity function tested for now, can make as list later
similarity_func <- function(exp_mat){calc_dot_product_similarity_matrix(calc_zscore_matrix(exp_mat))}
## only 1 clustering fucntion tested for now, can make as a list later
cluster_func <- function(sim_mat){add_weights(add_dist_to_parent(as.dendrogram(hclust(as.dist(1-sim_mat), method = "single") ) ))}  

```

```{r measure difference between 1 and all brain samples included}


flat <- rep(1,length(colnames(exp_mat))); names(flat) <- colnames(exp_mat)
## select which to be all non-brain and one brain
which <- c(grep("Brain", colnames(exp_mat), invert = TRUE ),sample(grep("Brain", colnames(exp_mat)),1))
spec_mat_flat_one <- calc_weighted_zscore_matrix(exp_mat[,which], flat[which])
spec_mat_flat_all  <- calc_weighted_zscore_matrix(exp_mat, flat)

df <- reshape2::melt(spec_mat_flat_all[,which], value.name = "spec_all")
df2 <- reshape2::melt(spec_mat_flat_one, value.name = "spec_one")
df <- merge(df,df2);rm(df2)
ggplot(df, aes(x=spec_all, y=spec_one))+
  geom_point()


## plot to look at global dif between flat and weighted
tau_flat_one <- calc_weighted_tau(exp_mat[,which], flat[which])
tau_flat_all <- calc_weighted_tau(exp_mat, flat)
tsi_flat_one <- calc_weighted_tsi(exp_mat[,which], flat[which])
tsi_flat_all <- calc_weighted_tsi(exp_mat,flat)
gini_flat_one <- calc_weighted_gini(exp_mat[,which], flat[which])
gini_flat_all <- calc_weighted_gini(exp_mat, flat)

plot(spec_mat_flat_all[,which],spec_mat_flat_one)
plot(tau_flat_all,tau_flat_one)
plot(tsi_flat_all, tsi_flat_one)
plot(gini_flat_all, gini_flat_one)

```


```{r measure sample similarity}
figures_dir <- paste(getwd(),"figures", sep = "/")
date <- format(Sys.time(), format="%Y%m%d") 

## dot similarity from initial Z scores
dot_sim <- similarity_func(exp_mat)

filename = paste(figures_dir, "/sample_similarity_heatmap.png", sep="")
png(filename = filename, width=10, height=10, units="in", res=300)
heatmap(dot_sim, Rowv = rev(sim_tree), Colv = sim_tree, scale = "none", margins=c(11,13))
dev.off()

sim_tree <- cluster_func(dot_sim)
## plot similarity tree with weights
filename = paste(figures_dir, "/weighted_tree.png", sep="")
png(filename = filename, width=9, height=4, units="in", res=300)
sim_tree %>% set("nodes_pch",19) %>% set("nodes_cex", 2*sqrt(get_nodes_attr(sim_tree,"weight"))) %>% plot
dev.off()


## take a look at the weights
temp <- get_weights(sim_tree, get_leaves_attr(sim_tree, "label"))
temp <- data.frame(weights=temp, names=factor(names(temp), levels=rev(names(temp)) ) )
g <- ggplot( temp ,aes(y=names, x=weights))+
  geom_col() #+
  #theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1))
g

filename = paste(figures_dir, "/sample_weights.png", sep="")
ggsave(filename, g, device = "png", width = 8, height = 8, dpi = 300)

weights <- get_weights(sim_tree, colnames(exp_mat))
spec_mat_weighted <- calc_weighted_zscore_matrix(exp_mat, weights = weights)
flat <- weights; flat[1:length(flat)] <- 1
spec_mat_flat  <- calc_weighted_zscore_matrix(exp_mat, flat)
## plot to look at global dif between flat and weighted
tau_flat <- calc_weighted_tau(exp_mat, flat)
tau_weighted <- calc_weighted_tau(exp_mat, weights)
tsi_flat <- calc_weighted_tsi(exp_mat,flat)
tsi_weighted <- calc_weighted_tsi(exp_mat,weights)
gini_flat <- calc_weighted_gini(exp_mat, flat)
gini_weighted <- calc_weighted_gini(exp_mat, weights)

hist(spec_mat_weighted ,breaks=100)
hist(tau_weighted ,breaks=100)
hist(tsi_weighted ,breaks=100)
hist(gini_weighted ,breaks=100)
hist(spec_mat_weighted - spec_mat_flat ,breaks=100)
hist(tau_weighted - tau_flat ,breaks=100)
hist(tsi_weighted - tsi_flat ,breaks=100)
hist(gini_weighted - gini_flat ,breaks=100)

```




```{r Figure_2C validation with variable sample set }
## load data instead
if(TRUE){  ## NOTE! This chunk can require a lot of memory and time depending if running sequential. If you want to look at robustness test results it is recommended you have enabled parallel computing (e.g. check getDoParWorkers > 3 or 4 (preferably more))
  
  ## Use this variable to control whether performing random or true brain-non-brain partition
  random_partition = TRUE
  
  
  robustness_test_results <- list( )
  for(i in 1:length(specificity_measures$func_names)){
    el_names <- paste( c( "P1_", "P2_")
                       , specificity_measures$func_names[i], sep="")
    temp_list <- setNames(list(list(), list()), nm=el_names  )
    robustness_test_results <- c(robustness_test_results, temp_list )
  }
  
  
  num_brain_samples <- length(colnames(exp_mat)[grep("[Bb]rain",colnames(exp_mat))])
  num_reps <- 8
  ## use general similarity_func and cluster_func in case we want to test more later
  similarity_func <- function(exp_mat){calc_dot_product_similarity_matrix(calc_zscore_matrix(exp_mat))}
  cluster_func <- function(sim_mat){add_weights(add_dist_to_parent(as.dendrogram(hclust(as.dist(1-sim_mat), method = "single") ) ))}  
  
  
  ## to switch analysis between True Brain Partition and equalivalent sized Random Partition set random_partition ##
  if(random_partition){
    which <- sample(1:ncol(exp_mat), length(grep("[Bb]rain",colnames(exp_mat),invert = TRUE)))
    P1 <- as.matrix(exp_mat[, which])
    notP1 <- as.matrix(exp_mat[, which(!is.element(1:ncol(exp_mat),which ))])
  }else{
    ## P1 and notP1 are contant throughout, so set these outside loops
    P1 <- as.matrix(exp_mat[,grep("[Bb]rain",colnames(exp_mat), invert = TRUE)])
    notP1 <- as.matrix(exp_mat[,grep("[Bb]rain",colnames(exp_mat), invert = FALSE)])
  }
  ### define 1-n trajectories ahead of time since i+1 should be referenced against i.
  ## do foreach over each element of permuation matrix ## use arrayInd to get row/col given perm number
  permutation_matrix <- matrix(nrow = num_brain_samples, ncol = num_reps )
  for(rep in 1:num_reps){
    permutation_matrix[,rep] <- sample(colnames(notP1),num_brain_samples, replace = FALSE)
  }
  if(!random_partition){
    load("final_permutation_matrix") ## reproduce same used in paper figures
  }
  if(random_partition){
    load("final_random_permutation_matrix") ## reproduce same used in paper figures
  }

  
  for(measure in specificity_measures$func_names){
    specificity_func <- specificity_measures$funcs[[measure]]
    if(!is.function(specificity_func)){print(paste(measure, "func is not a function")); next;}
    
      results <- foreach(perm=1:length(permutation_matrix), .errorhandling = "pass", .final = function(x) setNames(x,paste("rep=", arrayInd(1:length(permutation_matrix), dim(permutation_matrix))[,2], ",n=", arrayInd(1:length(permutation_matrix), dim(permutation_matrix ))[,1], sep = ""))) %dopar% {
      library(Hmisc)
      library(dendextend)
      library(reldist)
      sample_indices <- 1:(arrayInd(perm, dim(permutation_matrix))[,1]) ## row is sample name, all names in a row up to top are choices for n=1,2..i
      rep_index <- arrayInd(perm, dim(permutation_matrix))[,2] ## column is replicate number
      sample_set <- permutation_matrix[sample_indices, rep_index]
      
      # P1_baseline is just P1 at n=1
      P2 <- notP1[,sample_set, drop=F]; colnames(P2) <- make.unique(colnames(P2)) ## make.unique will facilitate sampling with replacement
      P1uP2 <- cbind(P1,P2)
      
      ## P1uP2 ## exp_mat > get sim mat > get sim tree > get samp weights > get spec mat
      sim_mat <- similarity_func(P1uP2)
      sim_tree <- cluster_func(sim_mat)
      weights <- get_weights(sim_tree, colnames(P1uP2))
      flat <- weights; flat[] <- 1
      
      
      specificity_flat <- specificity_func(P1uP2, flat)
      specificity_weighted <- specificity_func(P1uP2, weights)
      
      # need to fill in these with spec_score matrices for each n for each method
      # names should match 
      ### restore once error fixed
      if(specificity_measures$out_type[[measure]]=="matrix"){
        result <- list(
          P1_weighted_spec_score = specificity_weighted[,colnames(P1), drop=F],
          P1_flat_spec_score = specificity_flat[,colnames(P1), drop=F],
          P2_weighted_spec_score = specificity_weighted[,colnames(P2), drop=F],
          P2_flat_spec_score = specificity_flat[,colnames(P2), drop=F]
        )
      }else if(specificity_measures$out_type[[measure]]=="vector"){
        result <- list(P1_weighted_spec_score = specificity_weighted,
                        P1_flat_spec_score = specificity_flat,
                        P2_weighted_spec_score = specificity_weighted,
                        P2_flat_spec_score = specificity_flat
                        )
      }
      
      }
      
      results_P1 <- list()
      results_P2 <- list()
      for(i in 1:length(results)){
        name <- names(results)[i]
        rep <- str_split_fixed(names(results)[1], "[=,]", n=4)[,2]
        n <- str_split_fixed(names(results)[1], "[=,]", n=4)[,4]
        results_P1[[name]] <- list(P1_weighted_spec_score = results[[name]]$P1_weighted_spec_score, P1_flat_spec_score = results[[name]]$P1_flat_spec_score)
        results[[name]]$P1_weighted_spec_score <- NULL;  results[[name]]$P1_flat_spec_score <- NULL;  ## large object so delete as we go to avoid copy
        
        results_P2[[name]] <- list(P2_weighted_spec_score = results[[name]]$P2_weighted_spec_score, P2_flat_spec_score = results[[name]]$P2_flat_spec_score)
        results[[name]]$P2_weighted_spec_score <- NULL;  results[[name]]$P2_flat_spec_score<- NULL;  ## large object so delete as we go to avoid copy
      }
      
      robustness_test_results[[paste("P1_", measure,sep = "")]] <- results_P1; rm(results_P1)
      robustness_test_results[[paste("P2_", measure,sep = "")]] <- results_P2; rm(results_P2)
  }

  
} ## end of chunk control
## output to look at is robustness_test_results
#save.image()
```

```{r Figure_2C}
#system("mkdir figures")
figures_dir <- paste(getwd(),"figures", sep = "/")
date <- format(Sys.time(), format="%Y%m%d") 

df_robustness_test_results <- data.frame(measure=character(),
                                         P1orP2=character(),
                                         weight_or_flat=character(),
                                         n=numeric(),
                                         rep=numeric(),
                                         variance=numeric()
                                         )

for(el in 1:length(robustness_test_results)){
  if(length(robustness_test_results[[el]])==0){next;}
  temp_name <- str_split_fixed(names(robustness_test_results[el]),"_",2)
  
  temp_len <- length(robustness_test_results[[el]]) ## each has weighted and flat
  temp_df <- data.frame(measure=rep(temp_name[2],temp_len),
                        P1orP2=rep(temp_name[1],temp_len),
                        weight_or_flat=character(temp_len),
                        n=numeric(temp_len),
                        rep=numeric(temp_len),
                        variance=numeric(temp_len))
  temp_df_list <- list("weighted"=temp_df, "flat"=temp_df)
  temp_df_list[["weighted"]]$weight_or_flat <- "weighted"
  temp_df_list[["flat"]]$weight_or_flat <- "flat"
  
  ## build the temp_dfs in these loops
  for(i in 1:length(robustness_test_results[[el]])){
    for(f_or_w in c("flat","weighted")){
      temp_name <- str_split_fixed(names(robustness_test_results[[el]][i]),"[,=]",4)
      temp_df_list[[f_or_w]]$rep[i] <- as.numeric(temp_name[,grep("rep", temp_name)+1])
      temp_df_list[[f_or_w]]$n[i] <- as.numeric(temp_name[,grep("n", temp_name)+1])
      temp <- robustness_test_results[[el]][[i]]
      temp <- temp[[grep(f_or_w, names(temp))]]
      
      ## baseline matched on replicate, and is set at n=1
      temp_baseline <- robustness_test_results[[el]][[paste("rep=",temp_name[,grep("rep", temp_name)+1],",n=1",sep="")]]
      temp_baseline <- temp_baseline[[grep(f_or_w, names(temp_baseline))]]
      
      temp_df_list[[f_or_w]]$variance[i] <- var(as.vector(as.matrix(temp)) - as.vector(as.matrix(temp_baseline)), na.rm=T)
    }
  }
  ## compile temp_dfs into final result
  df_robustness_test_results <- rbind(df_robustness_test_results, temp_df_list[["weighted"]], temp_df_list[["flat"]])
  
}

df_2c <- df_robustness_test_results
df_2c_summary_by_partition <- aggregate(df_2c$variance,
                                     by=list(measure=df_2c$measure,
                                             P1orP2=df_2c$P1orP2,
                                             weight_or_flat= df_2c$weight_or_flat,
                                             n=df_2c$n),
                                     FUN=function(x) mean(x,na.rm=TRUE))
names(df_2c_summary_by_partition)[ncol(df_2c_summary_by_partition)] <- "mean_var"
df_2c_summary_by_partition$sd_of_var <- aggregate(df_2c$variance,
                                     by=list(measure=df_2c$measure,
                                             P1orP2=df_2c$P1orP2,
                                             weight_or_flat= df_2c$weight_or_flat,
                                             n=df_2c$n),
                                     FUN=function(x) sd(x,na.rm=TRUE))$x


temp <- df_2c_summary_by_partition
df_2c_summary_by_partition$y_min <-  temp$mean_var-temp$sd_of_var/sqrt(num_reps)
df_2c_summary_by_partition$y_max <-  temp$mean_var+temp$sd_of_var/sqrt(num_reps)


ggl <- list()
## Zscore first 
for(measure in c("Zscore", "notZscore")){
  if(measure == "Zscore"){
    which <- which(df_2c_summary_by_partition$measure == measure)
    which2 <- which(df_robustness_test_results$measure == measure)  
  } else {
    which <- which(df_2c_summary_by_partition$measure != "Zscore")
    which2 <- which(df_robustness_test_results$measure != "Zscore")
  }
  
  gg <- ggplot(df_2c_summary_by_partition[which,], aes(x=n, y=mean_var)) +
    scale_color_manual(values=c("grey20","steelblue3"))+
    scale_fill_manual(values=c("grey20","steelblue3"))+
    geom_ribbon(aes( group=weight_or_flat, ymin=y_min, ymax=y_max, fill=weight_or_flat),alpha=0.5)+
    geom_line(aes( group=weight_or_flat, ymin=y_min, ymax=y_max, color=weight_or_flat, fill=weight_or_flat))+
    geom_point(data = df_robustness_test_results[which2,], size=0.2,
               aes(x=n, y=variance,group=weight_or_flat,color=weight_or_flat, fill=weight_or_flat))+
    theme_bw()+
    theme(panel.grid.minor.x = element_blank())+
    scale_x_continuous(limits = c(0,13), breaks=seq(0,12,by=1), expand = c(0,0))
  
  if(measure == "Zscore"){
     gg <- gg+facet_wrap(measure ~ P1orP2 , scales = "free",
                         labeller=labeller(P1orP2=c("P1"="P1 (non-brain)", "P2"="P2 (brain)")))
     gg <- gg+theme(legend.position = "none")
  } else {
     gg <- gg+facet_wrap( ~ measure, ncol = 3); plot(gg)
     gg <- gg+theme(legend.position="bottom")
  }
  plot(gg)
  ggl[[measure]] <- gg
}

grobl <- list()
for(n in names(ggl)){
  grobl[[n]] <- ggplotGrob(ggl[[n]])
}
grid.arrange(grobs=grobl, ncol=2, widths=c(5,4))
g <-arrangeGrob(grobs=grobl, ncol=2, widths=c(5,4))

#grid.arrange(grobs=grobl, widths = c(1,1), layout_matrix = rbind(c(1,2),c(1,3),c(1,4))  )



#grid.arrange(ggl$Zscore, ggl$Tau, ggl$Tsi, ggl$Gini, nrow=2)

filename <- paste(figures_dir,"/",date,"_variance_random_v01.png",sep = "")
ggsave(filename, g, device = "png", width = 10, height = 3, dpi = 300)

## for random supplemental
if(FALSE){
  grid.arrange(grobs=grobl, nrow=2, heights=c(5,5))
  g <-arrangeGrob(grobs=grobl, nrow=2, heights=c(5,5))
  filename <- paste(figures_dir,"/",date,"_variance_random_v01.png",sep = "")
  ggsave(filename, g, device = "png", width = 7, height = 7, dpi = 300)
}


```

```{r 2C stats reported}
### stats reported in paper
## paired t-test for difference in means
### t = delta / sd / sqrt(n)
which_list <- list()
which_list[["Z_P1_flat"]] <- which(df_2c$measure=="Zscore" 
                    & df_2c$P1orP2=="P1"
                    & df_2c$n == max(df_2c$n)
                    & df_2c$weight_or_flat=="flat")
which_list[["Z_P1_weighted"]] <- which(df_2c$measure=="Zscore" 
                    & df_2c$P1orP2=="P1"
                    & df_2c$n == max(df_2c$n)
                    & df_2c$weight_or_flat=="weighted")
which_list[["Z_P2_flat"]] <- which(df_2c$measure=="Zscore" 
                    & df_2c$P1orP2=="P2"
                    & df_2c$n == max(df_2c$n)
                    & df_2c$weight_or_flat=="flat")
which_list[["Z_P2_weighted"]] <- which(df_2c$measure=="Zscore" 
                    & df_2c$P1orP2=="P2"
                    & df_2c$n == max(df_2c$n)
                    & df_2c$weight_or_flat=="weighted")

filename=paste(figures_dir,"/random_ttest_output.txt",sep="")
sink(file=filename)
print("t-test P1 weighted / P1 flat : %diff between weighted and flat")
## t.test on logs gives ratio estimates
temp <- t.test(x=log10(df_2c[which_list$Z_P1_weighted,]$variance),y=log10(df_2c[which_list$Z_P1_flat,]$variance) ,paired=TRUE, conf.level = 0.95)
##  antilog to recover ratio of weighted / flat
1-10^temp$estimate
1-10^temp$conf.int
### 79.3% lower variance in weighted than flat (CI)

print("t-test P2 weighted / P2 flat : %diff between weighted and flat")
temp <- t.test(x=log10(df_2c[which_list$Z_P2_weighted,]$variance),y=log10(df_2c[which_list$Z_P2_flat,]$variance) ,paired=TRUE, conf.level = 0.95)
1-10^temp$estimate
1-10^temp$conf.int
### 
sink()
```






```{r Figure_2D flat v weighted jaccard plot}
#system("mkdir figures")
figures_dir <- paste(getwd(),"figures", sep = "/")
date <- format(Sys.time(), format="%Y%m%d") 

## jaccard between n = 1 and n = num_brain_samples for brain v non-brain OR P1 v P2 

df_2d <- data.frame(measure=character(), n=numeric(),
                 rep=numeric(), cut_point=numeric(),
                 jaccard=numeric(), P1orP2=character(),
                 weighted=logical(), samp=character(),
                 gene_count=numeric(), gene_count_baseline=numeric(),
                 gene_count_intersect=numeric())
## nested for loop builds df of jaccard results for plotting
Sys.time()
for(el in names(robustness_test_results)){
  if(length(robustness_test_results[[el]])==0 ){next;}
  P1orP2 <- str_split_fixed(el,"_",n=2)[1]
  measure <- str_split_fixed(el,"_",n=2)[2]
  if(measure == "Zscore"){cuts <- seq(0,4,0.5)   ## set cutoffs
  }else{ cuts <- seq(0,1,0.05)}
  
 # for(i in 1:length(robustness_test_results[[el]]) ){   ### foreach at this level if implementing foreach
  df_temp <- foreach(i=1:length(robustness_test_results[[el]]), .errorhandling = "pass", .combine = rbind) %dopar% {
    #foreach(perm=1:length(permutation_matrix), .errorhandling = "pass", .final = function(x) setNames(x,paste("rep=", arrayInd(1:length(permutation_matrix), dim(permutation_matrix))[,2], ",n=", arrayInd(1:length(permutation_matrix), dim(permutation_matrix ))[,1], sep = ""))) %dopar% {
    library(stringr)
    df_internal <- data.frame(measure=character(), n=numeric(),
                              rep=numeric(), cut_point=numeric(), 
                              jaccard=numeric(), P1orP2=character(),
                              weighted=logical(), samp=character(),
                              gene_count=numeric(), gene_count_baseline=numeric(),
                              gene_count_intersect=numeric())
    
    n = as.numeric(str_split_fixed(names(robustness_test_results[[el]][i]), "[=,]", n=4 )[,4])
    rep = as.numeric(str_split_fixed(names(robustness_test_results[[el]][i]), "[=,]", n=4 )[,2])
    for(weighted_or_flat in c("weighted","flat")){
      baseline_name <- names(robustness_test_results[[el]])[grep(paste("rep=",rep,",n=",1,"$", sep = ""),names(robustness_test_results[[el]]) )]
      
      if(specificity_measures$out_type[measure] == "matrix"){
        weighted_flat_index <- grep(weighted_or_flat,names(robustness_test_results[[el]][[baseline_name]]))
        baseline_mat <-  robustness_test_results[[el]][[baseline_name]][[weighted_flat_index]]
        weighted_flat_index <- grep(weighted_or_flat,names(robustness_test_results[[el]][[i]]))
        temp_mat <- robustness_test_results[[el]][[i]][[weighted_flat_index]][,colnames(baseline_mat),drop=FALSE]  
      }else if(specificity_measures$out_type[measure] == "vector"){
        weighted_flat_index <- grep(weighted_or_flat,names(robustness_test_results[[el]][[baseline_name]]))
        baseline_mat <-  as.matrix(robustness_test_results[[el]][[baseline_name]][[weighted_flat_index]])
        weighted_flat_index <- grep(weighted_or_flat,names(robustness_test_results[[el]][[i]]))
        temp_mat <- as.matrix(robustness_test_results[[el]][[i]][[weighted_flat_index]])         
      }else{ stop("WARNING: no out type associated with measure") }
      
      ncols <- ncol(temp_mat); ncuts <- length(cuts)
      temp_df <- data.frame(measure=rep(measure, ncols*ncuts), n=rep(n, ncols*ncuts),
                            rep=rep(rep, ncols*ncuts), cut_point=numeric(length=ncols*ncuts),
                            jaccard=numeric(length=ncols*ncuts), P1orP2=rep(P1orP2, ncols*ncuts),
                            weighted=rep( grepl("weighted", weighted_or_flat), ncols*ncuts),
                            samp=character(length=ncols*ncuts),
                            gene_count=numeric(length=ncols*ncuts), gene_count_baseline=numeric(length=ncols*ncuts),
                            gene_count_intersect=numeric(length=ncols*ncuts)  )
      for(s in 1:ncol(temp_mat) ){  ## add a row to df for each sample   
        for(cut_index in 1:length(cuts)){
          ind <- (s-1)*length(cuts)+cut_index  ### use arr_ind here instead
          temp_df[ind,]$cut_point <- cuts[cut_index]
          if(cuts[cut_index]<0){
            temp_df[ind,]$jaccard <- (  length( which( baseline_mat[,s] <= cuts[cut_index] & temp_mat[,s] <= cuts[cut_index]  )) /
                                        length( which( baseline_mat[,s] <= cuts[cut_index] | temp_mat[,s] <= cuts[cut_index]  )) )
            temp_df[ind,]$gene_count <-  length( which(temp_mat[,s] <= cuts[cut_index]  ) )
            temp_df[ind,]$gene_count_baseline <- length( which(baseline_mat[,s] <= cuts[cut_index]  ) ) 
            temp_df[ind,]$gene_count_intersect <-  length( which( baseline_mat[,s] <= cuts[cut_index] & temp_mat[,s] <= cuts[cut_index]  ))
          } else {
            temp_df[ind,]$jaccard <- (  length( which( baseline_mat[,s] >= cuts[cut_index] & temp_mat[,s] >= cuts[cut_index]  )) /
                                        length( which( baseline_mat[,s] >= cuts[cut_index] | temp_mat[,s] >= cuts[cut_index]  )) )
            temp_df[ind,]$gene_count <-  length( which(temp_mat[,s] >= cuts[cut_index]  ) )
            temp_df[ind,]$gene_count_baseline <-  length( which(baseline_mat[,s] >= cuts[cut_index]  ) )
            temp_df[ind,]$gene_count_intersect <-  length( which( baseline_mat[,s] >= cuts[cut_index] & temp_mat[,s] >= cuts[cut_index]  ))
          }
          temp_df[ind,]$samp <- ifelse(!is.null((colnames(baseline_mat[,s,drop=FALSE] ) )),
                                       unique(colnames(baseline_mat[,s,drop=FALSE] ),
                                              colnames(temp_mat[,s,drop=FALSE] ) ), NA )
        }
      }
      df_internal <- rbind(df_internal, temp_df)
    }
    df_internal
  }
  df_2d <- rbind(df_2d, df_temp)
}
Sys.time()


df_2d_summary_by_partition <-aggregate(df_2d$jaccard, by=list(measure=df_2d$measure, n=df_2d$n,
                                                        cut_point=df_2d$cut_point, P1orP2=df_2d$P1orP2,
                                                        weighted=df_2d$weighted),
                                    FUN=function(x) mean(x,na.rm=TRUE) )
names(df_2d_summary_by_partition)[length(names(df_2d_summary_by_partition))] <- "jaccard_mean"
df_2d_summary_by_partition$jaccard_sd <- aggregate(df_2d$jaccard, by=list(measure=df_2d$measure, n=df_2d$n,
                                                        cut_point=df_2d$cut_point, P1orP2=df_2d$P1orP2,
                                                        weighted=df_2d$weighted) ,
                                                FUN=function(x) sd(x,na.rm = TRUE) )$x 
df_2d_summary_by_partition$gene_count <- aggregate(df_2d$gene_count,  by=list(measure=df_2d$measure, n=df_2d$n,
                                                        cut_point=df_2d$cut_point, P1orP2=df_2d$P1orP2,
                                                        weighted=df_2d$weighted)
                                                , FUN=function(x) mean(x,na.rm = TRUE) )$x 
df_2d_summary_by_partition$gene_count_baseline <- aggregate(df_2d$gene_count_baseline, by=list(measure=df_2d$measure, n=df_2d$n,
                                                        cut_point=df_2d$cut_point, P1orP2=df_2d$P1orP2,
                                                        weighted=df_2d$weighted),
                                                        FUN=function(x) mean(x,na.rm = TRUE) )$x 
df_2d_summary_by_partition$gene_count_intersect <- aggregate(df_2d$gene_count_intersect, by=list(measure=df_2d$measure, n=df_2d$n,
                                                        cut_point=df_2d$cut_point, P1orP2=df_2d$P1orP2,
                                                        weighted=df_2d$weighted),
                                                        FUN=function(x) mean(x,na.rm = TRUE) )$x 


  
ggl_jacc <- list()
for(measure in c("Zscore", "notZscore")){
  if(measure == "Zscore"){
    which <- which(df_2d_summary_by_partition$measure == measure)
  } else {
    which <- which(df_2d_summary_by_partition$measure != "Zscore")
  }
  gg <- ggplot(df_2d_summary_by_partition[which,],
               aes(x=cut_point, y=jaccard_mean,
                   ymin=jaccard_mean-jaccard_sd/num_reps, 
                   ymax=jaccard_mean+jaccard_sd/num_reps,
                   group=n, fill=n))+
    theme_bw()+
    theme(
          panel.grid.minor.x = element_blank())+
    #ggtitle(paste("jaccard index for ", measure, " P1 and  P2, weighted and flat measures",sep=""))+
    geom_line(aes(color=n))+
    scale_color_continuous(low="powderblue", high="steelblue4")+
    scale_y_continuous(limits = c(0,1), breaks=seq(0,1,by=0.2))+
    facet_grid(P1orP2 ~ weighted, labeller=labeller(weighted=c("TRUE"="weighted", "FALSE"="flat")) )
  if(measure == "Zscore"){
    gg <- gg+scale_x_continuous(limits = c(0,4), breaks=seq(0,4,by=0.5), expand = c(0,0))
    gg <- gg + facet_grid(weighted ~ P1orP2, labeller=labeller(weighted=c("TRUE"="weighted", "FALSE"="flat")) )
    gg <- gg+theme(legend.position = "none")
  } else {
    gg <- gg+scale_x_continuous(limits = c(0,1),  breaks=seq(0,1,by=0.1) ,expand = c(0,0))
    gg <- gg + facet_grid(weighted ~ measure, labeller=labeller(weighted=c("TRUE"="weighted", "FALSE"="flat")) )
    gg <- gg+theme(legend.position="bottom")
  }
  
  plot(gg)
  ggl_jacc[[measure]] <- gg
}

grobl <- list()
for(n in names(ggl_jacc)){
  grobl[[n]] <- ggplotGrob(ggl_jacc[[n]])
}
#grid.arrange(grobs =  list(grobl$Zscore, arrangeGrob(grobs=list(grobl$notZscore, grob()), ncol=2, widths=c(6,1)  ) ), nrow=2, heights=c(5,4) )
grid.arrange(grobs =list(grobl$Zscore, arrangeGrob(grobs=list(grobl$notZscore, grob()), nrow=2, heights=c(6,1)  ) ), ncol=2, widths=c(5,4) )
g <- arrangeGrob(grobs =grobl, ncol=2, widths=c(5,4) )
filename <- paste(figures_dir,"/",date,"_jaccard_random_v01.png",sep = "")
ggsave(filename, g, device = "png", width = 8, height = 3, dpi=300)

## for random supplemental
if(FALSE){
  grid.arrange(grobs = grobl, nrow=2, heights=c(5,4) )
  g <- arrangeGrob(grobs = grobl, nrow=2, heights=c(5,4) )
  filename <- paste(figures_dir,"/",date,"_jaccard_random_v01.png",sep = "")
  ggsave(filename, g, device = "png", width = 7, height = 7, dpi = 300)
}



ggl_count <- list()
for(measure in c("Zscore", "notZscore")){
  if(measure == "Zscore"){
    which <- which(df_2d_summary_by_partition$measure == measure)
  } else {
    which <- which(df_2d_summary_by_partition$measure != "Zscore")
  }
  gg <- ggplot(df_2d_summary_by_partition[which,],
               aes(x=cut_point, y=gene_count / nrow(genes),
                   group=n, fill=n))+
    theme_bw()+
    theme(
          panel.grid.minor.x = element_blank())+
    #ggtitle(paste("Number of genes above threshold for\n ", measure, " P1 and  P2, weighted and flat measures",sep=""))+
    geom_line(aes(color=n))+
    scale_color_continuous(low="steelblue2", high="steelblue4")+
    #scale_y_log10( #limits = c(1,3e4),
    scale_y_continuous( limits=c(1e-4,1) , trans = log10_trans(),
                       breaks = trans_breaks("log10", function(x) 10^x), # ) #,
                       labels = percent,  )
    
  if(measure == "Zscore"){
    gg <- gg+scale_x_continuous(limits = c(0,4), breaks=seq(0,4,by=0.5), expand = c(0,0))
    gg <- gg + facet_grid(P1orP2 ~ weighted, labeller=labeller(weighted=c("TRUE"="weighted", "FALSE"="flat")) )
    gg <- gg+theme(legend.position = "none")
  } else {
    gg <- gg+scale_x_continuous(limits = c(0,1),  breaks=seq(0,1,by=0.1) ,expand = c(0,0))
    gg <- gg + facet_grid(measure ~ weighted, labeller=labeller(weighted=c("TRUE"="weighted", "FALSE"="flat")) )
  }
  plot(gg)
  ggl_count[[measure]] <- gg
}
grobl <- list()
for(n in names(ggl_count)){
  grobl[[n]] <- ggplotGrob(ggl_count[[n]])
}
grid.arrange(grobs =  list(grobl$Zscore, arrangeGrob(grobs=list(grobl$notZscore, grob()), ncol=2, widths=c(6,1)  ) ), nrow=2, heights=c(5,4) )
g <- arrangeGrob(grobs =  list(grobl$Zscore, arrangeGrob(grobs=list(grobl$notZscore, grob()), ncol=2, widths=c(5,1)  ) ), nrow=2, heights=c(5,4) )
filename <- paste(figures_dir,"/",date,"_jaccard_gene_count_random_v01.png",sep = "")
ggsave(filename, g, device = "png", width = 6, height = 4)

## for random supplemental
if(FALSE){
  grid.arrange(grobs = grobl, nrow=2, heights=c(5,4) )
  g <- arrangeGrob(grobs = grobl, nrow=2, heights=c(5,4) )
  filename <- paste(figures_dir,"/",date,"_jaccard_gene_count_random_v01.png",sep = "")
  ggsave(filename, g, device = "png", width = 7, height = 7, dpi = 300)
}


```


```{r 2d stats reported}
### stats reported in paper
## paired t-test for difference in means
### t = delta / sd / sqrt(n)
which_list <- list()
which_list[["Z_P1_flat"]] <- which(df_2d$measure=="Zscore" 
                                   & df_2d$n==max(df_2d$n)
                                   & df_2d$cut_point==2
                                   & df_2d$P1orP2=="P1"
                                   & df_2d$weighted==FALSE)
which_list[["Z_P1_weighted"]] <- which(df_2d$measure=="Zscore" 
                                   & df_2d$n==max(df_2d$n)
                                   & df_2d$cut_point==2
                                   & df_2d$P1orP2=="P1"
                                   & df_2d$weighted==TRUE)

which_list[["Z_P2_flat"]] <- which(df_2d$measure=="Zscore" 
                                   & df_2d$n==max(df_2d$n)
                                   & df_2d$cut_point==2
                                   & df_2d$P1orP2=="P2"
                                   & df_2d$weighted==FALSE)
which_list[["Z_P2_weighted"]] <- which(df_2d$measure=="Zscore" 
                                   & df_2d$n==max(df_2d$n)
                                   & df_2d$cut_point==2
                                   & df_2d$P1orP2=="P2"
                                   & df_2d$weighted==TRUE)

filename=paste(figures_dir,"/random_ttest_jaccard_output.txt",sep="")
sink(file=filename)

print("t-test P2 flat jaccard")
temp <- t.test(x=df_2d[which_list$Z_P2_flat,]$jaccard, conf.level = 0.95)
temp$estimate
temp$conf.int

print("t-test P2 weighted jaccard")
temp <- t.test(x=df_2d[which_list$Z_P2_weighted,]$jaccard, conf.level = 0.95)
temp$estimate
temp$conf.int

print("t-test P1 flat jaccard")
temp <- t.test(x=df_2d[which_list$Z_P1_flat,]$jaccard, conf.level = 0.95)
temp$estimate
temp$conf.int

print("t-test P1 weighted jaccard")
temp <- t.test(x=df_2d[which_list$Z_P1_weighted,]$jaccard, conf.level = 0.95)
temp$estimate
temp$conf.int

sink()
```


```{r  Figure 3AB flat v weighted comparisons}
if(TRUE){

  ### Matrix built from Z score first then add columns of change in other scores
  ## NOT going to be general to arbitrary sets of matrix measures -> use only Z score and then concatenate other measures
  spec_mats <- list()
  
  sim_mat <- similarity_func(exp_mat)
  sim_tree <- cluster_func(sim_mat)
  weights <- get_weights(sim_tree, colnames(exp_mat))
  flat <- weights; flat[] <- 1
  for(measure in specificity_measures$func_names){
    specificity_func <- specificity_measures$funcs[[measure]]
    if(!is.function(specificity_func)){print(paste(measure, "func is not a function")); next;}
    if(specificity_measures$out_type[measure]=="matrix"){
      spec_mat_flat <- specificity_func(exp_mat, flat)
      spec_mat_weighted <- specificity_func(exp_mat, weights)
    } else if (specificity_measures$out_type[measure]=="vector"){
      spec_mat_flat <- as.matrix(specificity_func(exp_mat, flat))
      rownames(spec_mat_flat) <- rownames(exp_mat)
      spec_mat_weighted <- as.matrix(specificity_func(exp_mat, weights))
      rownames(spec_mat_weighted) <- rownames(exp_mat)
    } else { stop("WARNING: no out type associated with measure") }
    
    spec_mats[[paste("delta", measure,sep = "_")]] <- spec_mat_weighted - spec_mat_flat
    spec_mats[[paste("weighted", measure,sep = "_")]] <- spec_mat_weighted
    spec_mats[[paste("flat", measure,sep = "_")]] <- spec_mat_flat
  }
  
  ## look at top n and bottom n genes with greatest change in specificity score between weighted and flat
  gene_list <- list(up=list(),down=list()) 
  for(spec_mat_name in names(spec_mats)[grep("delta", names(spec_mats))] ){
    spec_mat <- spec_mats[[spec_mat_name]]
    measure <- str_split_fixed(spec_mat_name, "_", 2)[,2]
    ## for each tissue for matrix measures
    if(specificity_measures$out_type[measure]=="matrix"){
      n=5 ## top n for each tissue (column) of matrix
      temp_name <- measure
      gene_list$up[[temp_name]] <- data.frame("gene"=numeric())
      gene_list$down[[temp_name]] <- data.frame("gene"=numeric())
      ## go in same order as similarity tree
      for(i in get_leaves_attr(sim_tree, "label")){
        gene_list$up[[temp_name]] <- rbind(gene_list$up[[temp_name]],
                                           data.frame("gene"=rownames(spec_mat_flat)[order((spec_mat[,i]), decreasing = TRUE)[1:n]]))
      }
      for(i in get_leaves_attr(sim_tree, "label")){
        gene_list$down[[temp_name]] <- rbind(gene_list$down[[temp_name]],
                                           data.frame("gene" = rownames(spec_mat_flat)[order((spec_mat[,i]*(-1)), decreasing = TRUE)[1:n]])) 
        }
    } else if (specificity_measures$out_type[measure]=="vector"){
      # n=20 ## top n for each vector measure (single column) 
      # temp_name <- measure
      # gene_list$up[[temp_name]] <- data.frame("gene"=numeric())
      # gene_list$down[[temp_name]] <- data.frame("gene"=numeric())
      # ## go in same order as similarity tree
      # gene_list$up[[temp_name]] <- rbind(gene_list$up[[temp_name]],
      #                                    data.frame("gene"=rownames(spec_mat_flat)[order((spec_mat[,1]), decreasing = TRUE)[1:n]]))
      # gene_list$down[[temp_name]] <- rbind(gene_list$down[[temp_name]],
      #                                      data.frame("gene" = rownames(spec_mat_flat)[order((spec_mat[,1]*(-1)), decreasing = TRUE)[1:n]]))
    } else { stop("WARNING: no out type associated with measure") }
    
  }
 
  ### gene lists generated now to organize into heatmaps 
    ## set up color functions for heatmaps
  col_funs <- list()
  for(type in c("delta","flat","weighted")){
    col_funs[[paste( type, "Zscore" ,sep="_")]] <-colorRamp2(c(min(c(-2, min(spec_mats[[paste( type, "Zscore" ,sep="_")]], na.rm = T)) ),
                                        -1.99, -1, 0, 1, 1.99,
                                        max(c(2, max( spec_mats$delta_Zscore, na.rm = T) ) )),
                                      c("darkblue", "blue", "#B8B8FF" ,"white", "#FFB8B8",  "red","red4"))
    for(measure in specificity_measures$func_names[which(specificity_measures$out_type=="vector")]){
      # if(type=="delta"){
      #     col_funs[[paste(type, measure, sep="_")]] <- colorRamp2(c(-1,-0.25, 0 , 0.25, 1),
      #                                    c("darkblue", "blue", "white", "red", "red4") )
      # } else {
      #   col_funs[[paste(type,measure, sep="_")]] <- colorRamp2(c(0, 0.5, 1),
      #                                    c("white", "red", "red4") )
      # }
      # 
    }
  }
  
  ## get genes in top and bottom (note: genes may be repeated since want to see top n for each group )
  gene_vec <- data.frame(gene = character())
  for(ud in names(gene_list)){
    for(measure in names(gene_list[[ud]])){
      gene_vec <- rbind(gene_vec, gene_list[[ud]][[measure]]) 
    }
  }
  
  heatmaps <- list()
  for(type in c("delta", "flat", "weighted")){
    heatmaps[[type]] <- HeatmapList()
    for(measure in names(gene_list[["up"]])){
      spec_mat_name <- names(spec_mats)[intersect(grep(measure, names(spec_mats)), grep(type, names(spec_mats)))]
      spec_mat <-  spec_mats[[spec_mat_name ]]
      temp_name <- paste(spec_mat_name, sep="_")
      if(measure=="Zscore"){
        h1 <- Heatmap(spec_mat[gene_vec$gene,], name=temp_name,
                      row_order = gene_vec$gene, show_row_names = FALSE,
                      cluster_columns = sim_tree,
                      column_order = colnames(spec_mat),
                      col = col_funs[[paste(type,measure, sep="_")]])  
      } else { 
        h1 <- Heatmap(spec_mat[gene_vec$gene,], name=temp_name,
                      row_order = gene_vec$gene, show_row_names = FALSE,
                      col = col_funs[[paste(type,measure, sep="_")]])
      }
      if(length(heatmaps[[type]])==0){
        heatmaps[[type]] <- h1
      } else {
        heatmaps[[type]] <- heatmaps[[type]] + h1
      }
    }
    draw(heatmaps[[type]], padding = unit(c(0.9, 0.1, 0.3, 0.1), "in"))
  }
  
}

filename <- paste(figures_dir,"/",date,"_heatmap_v01.png",sep = "")
png(filename = filename, width=8, height=14, units="in", res=300)
heatmaps$delta
dev.off()


filename <- paste(figures_dir,"/",date,"_heatmap_fw_v01.png",sep = "")
png(filename = filename, width=16, height=14, units="in", res=300)
heatmaps$flat + heatmaps$weighted
dev.off()

```



```{r Figure 3C known marker genes}
## neural/brain marker: SOX1, SOX2, :: refs
## pancreatic marker: PRSS1, :: refs
## cardiac marker: , :: refs
## muscle marker: , :: refs
## arterial marker: , :: refs

head(gtex_rowinfo)
## create list of marker genes (common name and ENS map in genes object and gtex_rowinfo object)
#"NEUROD1","NEUROD2" ,"SOX2",  "TPPP","NEUROD4", "NEUROD6","MBP", "MAP2","GFAP" ,"NSG2","ADCY8","HEPACAM","VSTM2B","SLITRK3","MBP","MAP2","SOX2",  "TPPP","BCAN", "NCAN","OPALIN","STMN4", "GFAP" ,"NSG2","ADCY8",
specific_genes <- c( "OLIG1","OLIG2",
                     "PRSS1", "PTF1A", # "CTRB2",
                     "MYH6", "MYL4")
spec_genes_w_ids <- gtex_rowinfo[which( is.element(gtex_rowinfo$Description, specific_genes)),]
spec_genes_w_ids <- spec_genes_w_ids[which(is.element(spec_genes_w_ids$Name, rownames(spec_mats$delta_Zscore))),]
spec_genes_w_ids <- spec_genes_w_ids[match(specific_genes, spec_genes_w_ids$Description),]
spec_genes_w_ids <- merge( data.frame(f_or_w = c("flat","weighted")),spec_genes_w_ids)
spec_genes_w_ids <- spec_genes_w_ids[complete.cases(spec_genes_w_ids),]
 

col_funs <- list()
for(measure in unique(str_split_fixed(names(spec_mats), "_", 2)[,2] )){
  if(measure=="Zscore"){
    col_funs[[measure]] <-colorRamp2( c( min(c(min(spec_mats$weighted_Zscore[spec_genes_w_ids$Name,], na.rm = TRUE ),
                                             min(spec_mats$flat_Zscore[spec_genes_w_ids$Name,], na.rm = TRUE),-4)),
                                    #   -2, -1.99, 0, 1.99, 2, 3.99 ,
                                      -3, -2, 0, 2, 3, 3.99,
                                       max(c(max( spec_mats$weighted_Zscore[spec_genes_w_ids$Name,], na.rm = TRUE ), 
                                             max( spec_mats$flat_Zscore[spec_genes_w_ids$Name,]), na.rm = TRUE),4)),
                                     c("darkblue", "blue", "#aaaaff" ,"white", "#ffaaaa",  "red","red4", "grey20"))
                                    #c("darkblue", "blue", "#aaaaff" ,"white", "#ffaaaa",  "red","red4"))
  } else {
    col_funs[[measure]] <-colorRamp2(c( 0, 0.4, 0.6, 0.8, 1),
                                     c("white", "lightgoldenrod1","yellow" ,"red","red4"))
    #col_funs[[measure]] <-colorRamp2(c( 0, 0.5, 1),
    #                                 c("white","red","red4"))
  }
}


heatmaps <- HeatmapList()
for(measure in unique(str_split_fixed(names(spec_mats), "_", 2)[,2] )){
  temp_mat <- matrix(nrow=nrow(spec_genes_w_ids),ncol=ncol(spec_mats[[paste("delta",measure, sep = "_")]]))
  colnames(temp_mat) <- colnames(spec_mats[[paste("delta",measure, sep = "_")]])
  rownames(temp_mat) <- spec_genes_w_ids$Name
  for(i in 1:nrow(spec_genes_w_ids)){
    temp_mat[i,] <- spec_mats[[paste(spec_genes_w_ids$f_or_w[i], measure, sep = "_")]][spec_genes_w_ids$Name[i],]
  }
  if(measure=="Zscore"){
    split <- rep(1:(nrow(spec_genes_w_ids)/2), each=2)
    ra <- rowAnnotation(foo = anno_block(labels = unique(spec_genes_w_ids$Description)))
    h1 <- Heatmap(temp_mat, name=measure,
                  cluster_rows = FALSE, show_row_names = FALSE,
                  cluster_columns = sim_tree,
                  column_order = colnames(spec_mats$delta_Zscore),
                  row_split = split,
                  left_annotation = ra,
                  col = col_funs[[measure]] 
                  )
    } else {
      # h1 <- Heatmap(temp_mat, name=measure,
      #               cluster_rows = FALSE, show_row_names = TRUE,
      #               col = col_funs[[measure]])
      }
  if(length(heatmaps)==0){
      heatmaps <- h1
      # } else {
      # heatmaps <- heatmaps + h1
    }
}
draw(heatmaps)

filename <- paste(figures_dir,"/",date,"marker_genes_grad_v01.png",sep = "")
png(filename, width = 8, height = 7, units = "in", res=300 )
draw(heatmaps)
dev.off()


## get particular values reported in paper
measure="Zscore"
temp_mat <- matrix(nrow=nrow(spec_genes_w_ids),ncol=ncol(spec_mats[[paste("delta",measure, sep = "_")]]))
colnames(temp_mat) <- colnames(spec_mats[[paste("delta",measure, sep = "_")]])
rownames(temp_mat) <- spec_genes_w_ids$Name
for(i in 1:nrow(spec_genes_w_ids)){
  temp_mat[i,] <- spec_mats[[paste(spec_genes_w_ids$f_or_w[i], measure, sep = "_")]][spec_genes_w_ids$Name[i],]
}
rownames(temp_mat) <- paste(c("flat","weighted"), spec_genes_w_ids$Description)
```


```{r Figure 3D}
## gene ontology summaries
library(DOSE)
library(pathview)
library(clusterProfiler)
library(org.Hs.eg.db)

library(tidyverse)
library(topGO) 
library(enrichplot)

spec_mat_weighted <- calc_weighted_zscore_matrix(exp_mat, weights = weights)
flat <- weights; flat[1:length(flat)] <- 1
spec_mat_flat  <- calc_weighted_zscore_matrix(exp_mat, flat)

cutoff <- 2
which <- which((spec_mat_weighted >= cutoff & spec_mat_flat < cutoff))

allOE_genes<-str_split_fixed(rownames(spec_mat_flat),"[.]",2)[,1]

sigOE_genes <- character()
for(j in 1:ncol(spec_mat_weighted)){
 which<-which((spec_mat_flat[,j]<=2.0 & spec_mat_weighted[,j]>=2.0))
which<-as.matrix(which)
  which<- rownames(which)
  which<-str_split_fixed(which, "[.]", 2)
  which<- which[,1]
   sigOE_genes <- c(sigOE_genes, which)
}
sigOE_genes<-unique(sigOE_genes)


for(onto in c("BP")){ #},"MF","CC")){
  print(onto)
  ego <- enrichGO(gene = sigOE_genes, 
                  universe = allOE_genes,
                  keyType = "ENSEMBL",
                  OrgDb = org.Hs.eg.db, 
                  ont = onto, 
                  pAdjustMethod = "BH",
                  qvalueCutoff = 0.05,
                  readable = TRUE,
                  pool=TRUE)

  
  n=10
  filename <- paste(figures_dir,"/",date,"_go_dot_",onto,"_",n,".png",sep = "")
  print(filename)
  png(filename, width = 6, height = 10, units = "in", res=300 ) 
  print(dotplot(ego, showCategory = n))
  dev.off()
  
  filename <- paste(figures_dir,"/",date,"_go_clus_wo_labels",onto,"_",n,".png",sep = "")
  print(filename)
  png(filename, width = 8, height = 6, units = "in", res=300 )
  ego <- enrichplot::pairwise_termsim(ego)
  print(emapplot(ego, showCategory = n, node_label="none"))
  dev.off()
  
  filename <- paste(figures_dir,"/",date,"_go_graph_",onto,"_",n,".png",sep = "")
  print(filename)
  png(filename, width = 6, height = 7, units = "in", res=300 ) 
  print(goplot(ego, showCategory = n)) ## note needed to nest goplot in print function for this to write to file.. not sure why
  dev.off()
}

cluster_summary <- data.frame(ego)
cluster_summary$frac_terms <- as.numeric(str_split_fixed(cluster_summary$GeneRatio,"/",2)[,1] ) / as.numeric( str_split_fixed(cluster_summary$BgRatio,"/",2)[,1] )

```





