---
title: "specificity_paper_lncRNA"
output: html_document
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r libraries, include=FALSE}
library(ggplot2)
library(ggpubr)
library(biomaRt)
library(stringr)
library(dendextend)
library(dplyr)
library(Hmisc)
library(doParallel)
library(foreach)

library(ComplexHeatmap)
library(circlize)
library(scales)
library(reldist)
library(gridExtra)

library(DOSE)
library(pathview)
library(clusterProfiler)
library(org.Hs.eg.db)

library(tidyverse)
library(topGO) 
library(enrichplot)

library(data.table)

figures_dir <- paste(getwd(),"figures", sep = "/")
date <- format(Sys.time(), format="%Y%m%d") 

registerDoParallel(detectCores()-1)
```

## load gtex here
```{r import dataset}
## import gtex medians data
temp <- tempfile()
download.file("https://storage.googleapis.com/gtex_analysis_v8/rna_seq_data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz",temp)
gtex <- read.table( temp, skip=2, header = TRUE, sep = "\t")
gtex_rowinfo <- data.frame(Name=gtex$Name, Description=gtex$Description)
rownames(gtex) <- gtex$Name
gtex <- as.matrix(gtex[,3:ncol(gtex)])
unlink(temp); rm(temp)


## import ensembl gene data
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
genes <- getBM(attributes=c('chromosome_name','start_position','end_position','hgnc_symbol', 'ensembl_gene_id','gene_biotype'),
                 filters = list('biotype'=c('protein_coding','lincRNA')),
                 mart = ensembl, useCache = F) 
genes <- genes[which(is.element(genes$chromosome_name, c(1:22, "X", "Y", "MT")) & genes$ensembl_gene_id != "" ) ,]
```

## clean gtex dataset here
```{r clean dataset, fig.width = 8, fig.height=4}
## show mitochondrial genes drive a large part of sample similarity
## Note sum of medians in gtex not quite 1M - likely artifact of taking medians

temp <- data.frame(names=colnames(gtex), total_transcripts=colSums(gtex))
ggplot( temp ,aes(y=total_transcripts, x=names))+
  geom_col()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

## match genes between gtex and ensembl
gtex_names <- str_split_fixed(gtex_rowinfo$Name, "[.]", 2)[,1]
which <- which(genes$chromosome_name != "MT" )
gtex_cleaned <- gtex[which(is.element(gtex_names, genes$ensembl_gene_id[which])),]
which <- which(genes$chromosome_name == "MT" )
gtex_cleanedMT <- gtex[which(is.element(gtex_names, genes$ensembl_gene_id[which])),]

##non-mitochondrial TPM sum
temp <- data.frame(names=colnames(gtex_cleaned), total_transcripts=colSums(gtex_cleaned))
ggplot( temp ,aes(y=total_transcripts, x=names))+
  geom_col()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

##mitochondrial TPM sum
temp <- data.frame(names=colnames(gtex_cleanedMT), total_transcripts=colSums(gtex_cleanedMT))
ggplot( temp ,aes(y=total_transcripts, x=names))+
  geom_col()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

rm(gtex_cleanedMT)
##renormalize TPM without mitochondrial genes
for(i in 1:ncol(gtex_cleaned)){
  gtex_cleaned[,i] <- (gtex_cleaned[,i]*1e6 / sum(gtex_cleaned[,i]))
  ## set all very low counts to zero to avoid variable read depth issues
  gtex_cleaned[,i] [which(gtex_cleaned[,i]  < 1)] <- 0
  gtex_cleaned[,i] <- (gtex_cleaned[,i]*1e6 / sum(gtex_cleaned[,i]))
}

temp <- data.frame(names=colnames(gtex_cleaned), total_transcripts=colSums(gtex_cleaned))
ggplot( temp ,aes(y=total_transcripts, x=names))+
  geom_col()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

gtex <- gtex_cleaned; rm(gtex_cleaned)
exp_mat <- gtex

## log10(TPM+1) transform of data
exp_mat <- log10(exp_mat+1)

## remove mitochondrial contribution


## median normalization
temp <- exp_mat
temp[which(temp==0 | is.infinite(temp))] <- NA
boxplot(temp)
median_normalize <- TRUE
if(median_normalize){
  for(i in 1:ncol(exp_mat)){
    exp_mat[,i] <- exp_mat[,i] / median(exp_mat[,i][which(exp_mat[,i] > 0)])
  }
}
temp <- exp_mat
temp[which(temp==0)] <- NA
boxplot(temp)
```
```{r collected functions used, include=FALSE}

calc_zscore_matrix<- function(dat) {
  zscores <- dat; zscores[] <- 0 
  means <- rowMeans(dat)
  sds <- as.numeric(rep(NA,length(means)))
  which <- which(means != 0)
  sds[which] <- apply(dat[which,],1,sd)
  for(j in 1:ncol(dat)){zscores[,j] <- (dat[,j] - means)/sds  }
  return(zscores)
}

calc_dot_product_similarity_matrix <- function(dat) {
  dot_product_similarity_matrix <- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  colnames(dot_product_similarity_matrix) <- colnames(dat)
  rownames(dot_product_similarity_matrix) <- colnames(dat)
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)){
      which_i <- which(!is.na(dat[,i])) ## ignore NAs
      which_j <- which(!is.na(dat[,j])) ## ignore NAs
      dot_product_similarity_matrix[i,j] <- sum(dat[which_i,i] * dat[which_j,j]) / (norm(dat[which_i,i],"2")*norm(dat[which_j,j],"2"))
    }
  }
  return(dot_product_similarity_matrix)
}

### uses Equation 1. from paper 
add_dist_to_parent <- function(dend, dist_to_parent=0){
  ## note: distance to parent is fed in at the start of the function
  attributes(dend) <- c(attributes(dend), dist_to_parent=dist_to_parent)
  ## test if at leaf node
  if(!is.null(attributes(dend)$leaf) && attributes(dend)$leaf){
    return(dend)
  }
  for(i in 1:length(dend)){ ## length of dend should be number of child nodes
    ## distance to parent is simply the difference in height between parent and child
    dist_to_parent <- attributes(dend)$height - attributes(dend[[i]])$height 
    dend[[i]] <- add_dist_to_parent(dend[[i]], 
                                             dist_to_parent = dist_to_parent)
  }
  return(dend)
}

## this functions calculates and adds weights to dendrogram object using the 'dist_to_parent' attribute added previously
## weight_of_parent parameter exists only for recursion and should not be manually adjusted without understanding it's function
add_weights <- function(dend, weight_of_parent=0){
  weight <- (attributes(dend)$dist_to_parent / attributes(dend)$members) + weight_of_parent 
  attributes(dend) <- c(attributes(dend), weight=weight)
  ## test if at leaf node
  if(!is.null(attributes(dend)$leaf) && attributes(dend)$leaf){
    return(dend)
  }
  for(i in 1:length(dend)){ ## length of dend should be number of child nodes
    dend[[i]] <- add_weights(dend[[i]], weight_of_parent=weight)
  }
  return(dend)
}

## this function returns the weights from a dendrogram object that has a "weight" attribute at leaves. Also requires the order of the vector to return based on names of leaves
get_weights <- function(dend, name_order){
  weights <- setNames(get_leaves_attr(dend,"weight"),nm=get_leaves_attr(dend,"lab") )
  weights <- weights[order(factor(names(weights),levels = name_order))]
  return(weights)
}


# function to calculate weighted zscores given matrix and vector of weights. column names of the matrix and names of the weight vector must match
calc_weighted_zscore_matrix <- function(mat, weights){
  if(any( colnames(mat) != names(weights) )){stop("WARNING: mismatch in weights names and matrix colnames order")}
  weighted_mat <- mat; weighted_mat[] <- 0
  for (i in 1:length(weights)){
    weighted_mat[,i] <- weights[i]*mat[,i]
  }
  weighted_means <- numeric(length = nrow(weighted_mat))
  sum_of_weights <- sum(weights)
  for (i in 1:nrow(weighted_mat)){
    weighted_means[i] <- sum(weighted_mat[i,]) / sum_of_weights
  }
  weighted_var <- numeric(length=nrow(mat))
  for (i in 1:nrow(mat)){
    weighted_var[i] <- Hmisc::wtd.var(mat[i,],weights=weights)
  }
  weighted_sd <- sqrt(weighted_var)
  for(i in 1:ncol(mat)){
    mat[,i] <- (mat[,i]-weighted_means)/weighted_sd
  }
  weighted_zscores <- mat
  return(weighted_zscores)
}



# weighted tau
calc_weighted_tau <- function(te_matrix, weights_vector){
  xhat_matrix <- matrix(nrow=nrow(te_matrix),ncol=ncol(te_matrix))
  te_row_maxima <- apply(te_matrix, 1, max)
  for(j in 1:ncol(te_matrix)){
    xhat_matrix[,j] <- te_matrix[,j] / te_row_maxima
  }
  temp_matrix <- matrix(nrow=nrow(te_matrix),ncol=ncol(te_matrix))
  for (i in 1:nrow(te_matrix)){
    temp_matrix[i,] <- weights_vector - (xhat_matrix[i,] * weights_vector)
  }
  tau <- numeric(length = nrow(temp_matrix))
  for (i in 1:nrow(temp_matrix)){
    temp <- sum(temp_matrix[i,]) / (sum(weights_vector) - weights_vector[which.max(temp_matrix[i,])])
    tau[i] <- ifelse(length(temp)==0,NA,temp)
  }
  
  ## add normalization (believe this is a numeric instability issue from dividing small numbers)
  # tau <- tau / max(tau, na.rm=T)
  ## alternative, set all > 1 to 1 (when looking at plots for different cutoffs, normalizing true 1 values causes issue)
  tau[which(tau > 1)] <- 1
  return(tau)
}

calc_weighted_tsi <- function(te_matrix,weights_vector){
  weighted_matrix <- t(apply(te_matrix,1, "*", weights_vector))
  tsi <- numeric(length=nrow(weighted_matrix))
  for(i in 1:nrow(weighted_matrix)){
    tsi[i] <- weights_vector[which.max(te_matrix[i,])] * max(te_matrix[i,]) / sum(weighted_matrix[i,]) 
  }
  names(tsi) <- rownames(te_matrix)
  return(tsi)
}

calc_weighted_gini <- function(te_matrix, weights_vector){
   gini_values <-  c()
  for (i in 1:nrow(te_matrix)){
    temp <- as.numeric(te_matrix[i,])
    temp <- reldist::gini(temp, weights_vector)
    gini_values <- append(gini_values,temp)
  }
  return(gini_values)
}


```

```{r organizing functions into lists, include=FALSE}
### generalizing a list to store results in - this will make it easier to extend later if necessary.
## Note: only need the weighted version of each equation as each simplifies to flat version when all weights are 1
specificity_measures <- list(func_names=c("Zscore", "Tau", "Tsi","Gini"),
                             funcs=list(Zscore=calc_weighted_zscore_matrix,
                                        Tau=calc_weighted_tau,
                                        Tsi=calc_weighted_tsi,
                                        Gini=calc_weighted_gini),
                             out_type=list(Zscore="matrix",
                                           Tau="vector",
                                           Tsi="vector",
                                           Gini="vector")
                             )
## only 1 similarity function tested for now, can make as list later
similarity_func <- function(exp_mat){calc_dot_product_similarity_matrix(calc_zscore_matrix(exp_mat))}
## only 1 clustering fucntion tested for now, can make as a list later
cluster_func <- function(sim_mat){add_weights(add_dist_to_parent(as.dendrogram(hclust(as.dist(1-sim_mat), method = "average") ) ))}  

```

```{r  Figure 3AB flat v weighted comparisons, fig.width = 8, fig.height=12}
if(TRUE){

  ### Matrix built from Z score first then add columns of change in other scores
  ## NOT going to be general to arbitrary sets of matrix measures -> use only Z score and then concatenate other measures
  spec_mats <- list()
  
  sim_mat <- similarity_func(exp_mat)
  sim_tree <- cluster_func(sim_mat)
  weights <- get_weights(sim_tree, colnames(exp_mat))
  flat <- weights; flat[] <- 1
  for(measure in specificity_measures$func_names){
    specificity_func <- specificity_measures$funcs[[measure]]
    if(!is.function(specificity_func)){print(paste(measure, "func is not a function")); next;}
    if(specificity_measures$out_type[measure]=="matrix"){
      spec_mat_flat <- specificity_func(exp_mat, flat)
      spec_mat_weighted <- specificity_func(exp_mat, weights)
    } else if (specificity_measures$out_type[measure]=="vector"){
      spec_mat_flat <- as.matrix(specificity_func(exp_mat, flat))
      rownames(spec_mat_flat) <- rownames(exp_mat)
      spec_mat_weighted <- as.matrix(specificity_func(exp_mat, weights))
      rownames(spec_mat_weighted) <- rownames(exp_mat)
    } else { stop("WARNING: no out type associated with measure") }
    
    spec_mats[[paste("delta", measure,sep = "_")]] <- spec_mat_weighted - spec_mat_flat
    spec_mats[[paste("weighted", measure,sep = "_")]] <- spec_mat_weighted
    spec_mats[[paste("flat", measure,sep = "_")]] <- spec_mat_flat
  }
  
  ## look at top n and bottom n genes with greatest change in specificity score between weighted and flat
  gene_list <- list(up=list(),down=list()) 
  for(spec_mat_name in names(spec_mats)[grep("delta", names(spec_mats))] ){
    spec_mat <- spec_mats[[spec_mat_name]]
    measure <- str_split_fixed(spec_mat_name, "_", 2)[,2]
    ## for each tissue for matrix measures
    if(specificity_measures$out_type[measure]=="matrix"){
      n=5 ## top n for each tissue (column) of matrix
      temp_name <- measure
      gene_list$up[[temp_name]] <- data.frame("gene"=numeric())
      gene_list$down[[temp_name]] <- data.frame("gene"=numeric())
      ## go in same order as similarity tree
      which <- which(is.element(str_split_fixed(rownames(spec_mat),"\\.",2 )[,1],
                                  genes$ensembl_gene_id[which(genes$gene_biotype=="lincRNA")] ))
      for(i in get_leaves_attr(sim_tree, "label")){
        gene_list$up[[temp_name]] <- rbind(gene_list$up[[temp_name]],
                                           data.frame("gene"=rownames(spec_mat_flat)[which][order((
                                             spec_mat[which,i]), decreasing = TRUE)[1:n]]))
      }
      for(i in get_leaves_attr(sim_tree, "label")){
        gene_list$down[[temp_name]] <- rbind(gene_list$down[[temp_name]],
                                           data.frame("gene" = rownames(spec_mat_flat)[which][order((spec_mat[which,i]*(-1)), decreasing = TRUE)[1:n]])) 
        }
    } else if (specificity_measures$out_type[measure]=="vector"){
    } else { stop("WARNING: no out type associated with measure") }
    
  }
 
  ### gene lists generated now to organize into heatmaps 
    ## set up color functions for heatmaps
  col_funs <- list()
  for(type in c("delta","flat","weighted")){
    col_funs[[paste( type, "Zscore" ,sep="_")]] <-colorRamp2(c(min(c(-2, min(spec_mats[[paste( type, "Zscore" ,sep="_")]], na.rm = T)) ),
                                        -1.99, -1, 0, 1, 1.99,
                                        max(c(2, max( spec_mats$delta_Zscore, na.rm = T) ) )),
                                      c("darkblue", "blue", "#B8B8FF" ,"white", "#FFB8B8",  "red","red4"))
    for(measure in specificity_measures$func_names[which(specificity_measures$out_type=="vector")]){
      # if(type=="delta"){
      #     col_funs[[paste(type, measure, sep="_")]] <- colorRamp2(c(-1,-0.25, 0 , 0.25, 1),
      #                                    c("darkblue", "blue", "white", "red", "red4") )
      # } else {
      #   col_funs[[paste(type,measure, sep="_")]] <- colorRamp2(c(0, 0.5, 1),
      #                                    c("white", "red", "red4") )
      # }
      # 
    }
  }
  
  ## get genes in top and bottom (note: genes may be repeated since want to see top n for each group )
  gene_vec <- data.frame(gene = character())
  for(ud in names(gene_list)){
    for(measure in names(gene_list[[ud]])){
      gene_vec <- rbind(gene_vec, gene_list[[ud]][[measure]]) 
    }
  }
  
  heatmaps <- list()
  for(type in c("delta", "flat", "weighted")){
    heatmaps[[type]] <- HeatmapList()
    for(measure in names(gene_list[["up"]])){
      spec_mat_name <- names(spec_mats)[intersect(grep(measure, names(spec_mats)), grep(type, names(spec_mats)))]
      spec_mat <-  spec_mats[[spec_mat_name ]]
      temp_name <- paste(spec_mat_name, sep="_")
      if(measure=="Zscore"){
        h1 <- Heatmap(spec_mat[gene_vec$gene,], name=temp_name,
                      row_order = gene_vec$gene, show_row_names = FALSE,
                      cluster_columns = sim_tree,
                      column_order = colnames(spec_mat),
                      col = col_funs[[paste(type,measure, sep="_")]])  
      } else { 
        h1 <- Heatmap(spec_mat[gene_vec$gene,], name=temp_name,
                      row_order = gene_vec$gene, show_row_names = FALSE,
                      col = col_funs[[paste(type,measure, sep="_")]])
      }
      if(length(heatmaps[[type]])==0){
        heatmaps[[type]] <- h1
      } else {
        heatmaps[[type]] <- heatmaps[[type]] + h1
      }
    }
    draw(heatmaps[[type]], padding = unit(c(0.9, 0.1, 0.3, 0.1), "in"))
  }
  
}

filename <- paste(figures_dir,"/",date,"_lnc_heatmap.png",sep = "")
png(filename = filename, width=8, height=14, units="in", res=300)
heatmaps$delta
dev.off()


filename <- paste(figures_dir,"/",date,"_lnc_heatmap_fw_v01.png",sep = "")
png(filename = filename, width=16, height=14, units="in", res=300)
heatmaps$flat + heatmaps$weighted
dev.off()


## write csvs of flat v weighted tables for supplement
library("writexl")
temp_list<-list()
for(i in 1:length(spec_mats)){
  if(grepl("delta",names(spec_mats)[i])){next;}
  temp_list[[names(spec_mats)[i] ]] <- merge(gtex_rowinfo, cbind( Name=rownames(spec_mats[[1]][which]),    data.frame(signif(spec_mats[[i]][which],3) )) )
}

filename <- paste(figures_dir, "/lnc_specificity_scores_full_Gtex.xlsx",sep = "")
write_xlsx(temp_list, filename)

```


```{r comparison of specificity scores for lincRNA and protien coding rna}

hist(rowMax(na.omit(spec_mats$weighted_Zscore)))

names(spec_mats)


which_protein_coding <- which(genes$gene_biotype == "protein_coding")
which_lincRNA <- which(genes$gene_biotype == "lincRNA")

which_not_testis_max <- which(rowMax(exp_mat) != exp_mat[,"Testis"])
temp_rownames_all <- str_split_fixed(rownames(spec_mats$delta_Zscore)[which_not_testis_max],"\\.",2)[,1]
which_brain_max <- which(rowMax(exp_mat) == rowMax(exp_mat[,grep("brain", colnames(exp_mat),ignore.case = T)]) &
                           rowMax(exp_mat) > 0.01)
temp_rownames_brain <- str_split_fixed(rownames(spec_mats$delta_Zscore)[which_brain_max],"\\.",2)[,1]

gene_subsets <- list()

gene_subsets$protein_coding_all <- rownames(spec_mats$delta_Zscore)[which_not_testis_max][which(is.element(temp_rownames_all,
                                                    genes$ensembl_gene_id[which_protein_coding]))] 
gene_subsets$protein_coding_brain <- rownames(spec_mats$delta_Zscore)[which_brain_max][which(is.element(temp_rownames_brain,
                                                    genes$ensembl_gene_id[which_protein_coding]))]
gene_subsets$lincRNA_all <- rownames(spec_mats$delta_Zscore)[which_not_testis_max][which(is.element(temp_rownames_all,
                                                    genes$ensembl_gene_id[which_lincRNA]))]
gene_subsets$lincRNA_brain <- rownames(spec_mats$delta_Zscore)[which_brain_max][which(is.element(temp_rownames_brain,
                                                    genes$ensembl_gene_id[which_lincRNA]))]

df_lnc_pc <- data.frame(measure=character(),
                        w_or_f=character(),
                        linc_or_pc=character(),
                        brain_or_all=character(),
                        spec_val=numeric())
for(el in names(spec_mats)){
  if(grepl("delta", el)){next}
  #if(grepl("flat", el)){next}
  measure <- str_split_fixed(el,"_",n=2)[2]
  w_or_f <- str_split_fixed(el,"_",n=2)[1]
  # if(measure == "Zscore"){cuts <- seq(0,4,0.5)   ## set cutoffs
  # }else{ cuts <- seq(0,1,0.05)}
  # el_pair <- intersect( grep(measure, names(spec_mats) ),
  #                       grep(ifelse(w_or_f=="weighted", "flat","weighted"), names(spec_mats) ))
  
  if(measure=="Zscore"){
    temp_spec_val_lnc_all <- rowMax(na.omit(spec_mats[[el]][gene_subsets$lincRNA_all,] ))
    temp_spec_val_lnc_brain <- rowMax(na.omit(spec_mats[[el]][gene_subsets$lincRNA_brain,] ))
    temp_spec_val_pc_all <- rowMax(na.omit(spec_mats[[el]][gene_subsets$protein_coding_all,] ))
    temp_spec_val_pc_brain <- rowMax(na.omit(spec_mats[[el]][gene_subsets$protein_coding_brain,] ))
  } else {
    temp_spec_val_lnc_all <- na.omit(spec_mats[[el]][gene_subsets$lincRNA_all,])
    temp_spec_val_lnc_brain <- na.omit(spec_mats[[el]][gene_subsets$lincRNA_brain,])
    temp_spec_val_pc_all <- na.omit(spec_mats[[el]][gene_subsets$protein_coding_all,])
    temp_spec_val_pc_brain <- na.omit(spec_mats[[el]][gene_subsets$protein_coding_brain,])
  }
  df_lnc_pc <- rbind(df_lnc_pc,
                     data.frame(measure=measure,
                                w_or_f=w_or_f,
                                linc_or_pc="lincRNA",
                                brain_or_all="all",
                                spec_val= temp_spec_val_lnc_all),
                     data.frame(measure=measure,
                                w_or_f=w_or_f,
                                linc_or_pc="lincRNA",
                                brain_or_all="brain",
                                spec_val= temp_spec_val_lnc_brain),
                     data.frame(measure=measure,
                                w_or_f=w_or_f,
                                linc_or_pc="protein_coding",
                                brain_or_all="all",
                                spec_val= temp_spec_val_pc_all),
                     data.frame(measure=measure,
                                w_or_f=w_or_f,
                                linc_or_pc="protein_coding",
                                brain_or_all="brain",
                                spec_val= temp_spec_val_pc_brain))

}

df_lnc_pc$wf_lincpc <- paste(df_lnc_pc$linc_or_pc,df_lnc_pc$w_or_f ,sep = "_")
df_lnc_pc_means <- aggregate(spec_val ~ measure+brain_or_all+wf_lincpc,df_lnc_pc, mean)

ggplot(df_lnc_pc[which(df_lnc_pc$measure != "Zscore"),], aes(x=spec_val, color=wf_lincpc)) +
  geom_density(size=0.8)+
  geom_vline(data=df_lnc_pc_means[which(df_lnc_pc_means$measure != "Zscore"),],
             aes(xintercept=spec_val, color=wf_lincpc),linetype="dashed",size=0.8)+
  scale_color_manual(values=c("steelblue4","steelblue2","orange4","orange2"))+
  theme_bw()+
  facet_grid(measure ~ brain_or_all, scales = "free")


ggplot(df_lnc_pc[which(df_lnc_pc$measure != "Zscore"),], aes(x=spec_val, color=wf_lincpc)) +
  geom_density(size=0.8)+
  geom_vline(data=df_lnc_pc_means[which(df_lnc_pc_means$measure != "Zscore"),],
             aes(xintercept=spec_val, color=wf_lincpc),linetype="dashed",size=0.8)+
  scale_color_manual(values=c("steelblue4","steelblue2","orange4","orange2"))+
  theme_bw()+
  facet_grid(measure ~ brain_or_all, scales = "free")
ggsave(filename="./Figures/lncRNA_v_proteinCoding_nonZscore.png",
       plot=last_plot(),
       device = "png",
       width = 6, height=5, units="in",
       dpi=250)



ggplot(df_lnc_pc[which(df_lnc_pc$measure == "Zscore"),], aes(x=spec_val, color=wf_lincpc)) +
  geom_density(size=0.8)+
  geom_vline(data=df_lnc_pc_means[which(df_lnc_pc_means$measure == "Zscore"),],
             aes(xintercept=spec_val, color=wf_lincpc),linetype="dashed",size=0.8)+
  scale_color_manual(values=c("steelblue4","steelblue2","orange4","orange2"))+
  theme_bw()+
  facet_grid(measure ~ brain_or_all, scales = "free")
ggsave(filename="./Figures/lncRNA_v_proteinCoding_Zscore.png",
       plot=last_plot(),
       device = "png",
       width = 6, height=2.3, units="in",
       dpi=250)

```


```{r Figure 3C known marker genes}
## neural/brain marker: SOX1, SOX2, :: refs
## pancreatic marker: PRSS1, :: refs
## cardiac marker: , :: refs
## muscle marker: , :: refs
## arterial marker: , :: refs

head(gtex_rowinfo)
## create list of marker genes (common name and ENS map in genes object and gtex_rowinfo object)
#"NEUROD1","NEUROD2" ,"SOX2",  "TPPP","NEUROD4", "NEUROD6","MBP", "MAP2","GFAP" ,"NSG2","ADCY8","HEPACAM","VSTM2B","SLITRK3","MBP","MAP2","SOX2",  "TPPP","BCAN", "NCAN","OPALIN","STMN4", "GFAP" ,"NSG2","ADCY8",
specific_genes <- c( "OLIG1","OLIG2",
                     "PRSS1", "CTRB2", # "CTRB2",
                     "MYH6", "MYL4")
spec_genes_w_ids <- gtex_rowinfo[which( is.element(gtex_rowinfo$Description, specific_genes)),]
spec_genes_w_ids <- spec_genes_w_ids[which(is.element(spec_genes_w_ids$Name, rownames(spec_mats$delta_Zscore))),]
spec_genes_w_ids <- spec_genes_w_ids[match(specific_genes, spec_genes_w_ids$Description),]
spec_genes_w_ids <- merge( data.frame(f_or_w = c("flat","weighted")),spec_genes_w_ids)
spec_genes_w_ids <- spec_genes_w_ids[complete.cases(spec_genes_w_ids),]
 

col_funs <- list()
for(measure in unique(str_split_fixed(names(spec_mats), "_", 2)[,2] )){
  if(measure=="Zscore"){
    col_funs[[measure]] <-colorRamp2( c( min(c(min(spec_mats$weighted_Zscore[spec_genes_w_ids$Name,], na.rm = TRUE ),
                                             min(spec_mats$flat_Zscore[spec_genes_w_ids$Name,], na.rm = TRUE),-4)),
                                    #   -2, -1.99, 0, 1.99, 2, 3.99 ,
                                      -3, -2, 0, 2, 3, 3.99,
                                       max(c(max( spec_mats$weighted_Zscore[spec_genes_w_ids$Name,], na.rm = TRUE ), 
                                             max( spec_mats$flat_Zscore[spec_genes_w_ids$Name,]), na.rm = TRUE),4)),
                                     c("darkblue", "blue", "#aaaaff" ,"white", "#ffaaaa",  "red","red4", "grey20"))
                                    #c("darkblue", "blue", "#aaaaff" ,"white", "#ffaaaa",  "red","red4"))
  } else {
    col_funs[[measure]] <-colorRamp2(c( 0, 0.4, 0.6, 0.8, 1),
                                     c("white", "lightgoldenrod1","yellow" ,"red","red4"))
    #col_funs[[measure]] <-colorRamp2(c( 0, 0.5, 1),
    #                                 c("white","red","red4"))
  }
}


heatmaps <- HeatmapList()
for(measure in unique(str_split_fixed(names(spec_mats), "_", 2)[,2] )){
  temp_mat <- matrix(nrow=nrow(spec_genes_w_ids),ncol=ncol(spec_mats[[paste("delta",measure, sep = "_")]]))
  colnames(temp_mat) <- colnames(spec_mats[[paste("delta",measure, sep = "_")]])
  rownames(temp_mat) <- spec_genes_w_ids$Name
  for(i in 1:nrow(spec_genes_w_ids)){
    temp_mat[i,] <- spec_mats[[paste(spec_genes_w_ids$f_or_w[i], measure, sep = "_")]][spec_genes_w_ids$Name[i],]
  }
  if(measure=="Zscore"){
    split <- rep(1:(nrow(spec_genes_w_ids)/2), each=2)
    ra <- rowAnnotation(foo = anno_block(labels = unique(spec_genes_w_ids$Description)))
    h1 <- Heatmap(temp_mat, name=measure,
                  cluster_rows = FALSE, show_row_names = FALSE,
                  cluster_columns = sim_tree,
                  column_order = colnames(spec_mats$delta_Zscore),
                  row_split = split,
                  left_annotation = ra,
                  col = col_funs[[measure]] 
                  )
    } else {
      # h1 <- Heatmap(temp_mat, name=measure,
      #               cluster_rows = FALSE, show_row_names = TRUE,
      #               col = col_funs[[measure]])
      }
  if(length(heatmaps)==0){
      heatmaps <- h1
      # } else {
      # heatmaps <- heatmaps + h1
    }
}
draw(heatmaps)

filename <- paste(figures_dir,"/",date,"marker_genes_grad_v01.png",sep = "")
#png(filename, width = 8, height = 7, units = "in", res=300 )
#draw(heatmaps)
#dev.off()


## get particular values reported in paper
measure="Zscore"
temp_mat <- matrix(nrow=nrow(spec_genes_w_ids),ncol=ncol(spec_mats[[paste("delta",measure, sep = "_")]]))
colnames(temp_mat) <- colnames(spec_mats[[paste("delta",measure, sep = "_")]])
rownames(temp_mat) <- spec_genes_w_ids$Name
for(i in 1:nrow(spec_genes_w_ids)){
  temp_mat[i,] <- spec_mats[[paste(spec_genes_w_ids$f_or_w[i], measure, sep = "_")]][spec_genes_w_ids$Name[i],]
}
rownames(temp_mat) <- paste(c("flat","weighted"), spec_genes_w_ids$Description)
```

```{r Supp gene count specific at variable cutoffs}

df_gc <- data.frame(measure=character(), weighted=logical(), 
                      cut_point=numeric(), gene_count=numeric(),
                      total=numeric(), brain=logical())
df_gc_jaccard <- data.frame(measure=character(), cut_point=numeric(),
                              jaccard=numeric(), brain=logical())

for(el in names(spec_mats)){
  if(grepl("delta", el)){next}
  measure <- str_split_fixed(el,"_",n=2)[2]
  w_or_f <- str_split_fixed(el,"_",n=2)[1]
  if(measure == "Zscore"){cuts <- seq(0,4,0.5)   ## set cutoffs
  }else{ cuts <- seq(0,1,0.05)}
  el_pair <- intersect( grep(measure, names(spec_mats) ),
                        grep(ifelse(w_or_f=="weighted", "flat","weighted"), names(spec_mats) ))
  ncuts <- length(cuts)
  for(only_brain in c(T,F)){
    temp_df_gc <- data.frame(measure=rep(measure, ncuts), 
                             weighted=rep( grepl("weighted", w_or_f), ncuts),
                             cut_point=numeric(length=ncuts), gene_count=numeric(length=ncuts),
                             total=nrow(spec_mats[[el]])*ncol(spec_mats[[el]]), brain=only_brain)
    temp_df_gc_jaccard <- data.frame(measure=rep(measure, ncuts),
                             cut_point=numeric(length=ncuts),
                             jaccard=numeric(length=ncuts), brain=only_brain)
    for(cut_index in 1:length(cuts)){
      temp_df_gc$cut_point[cut_index] <- cuts[cut_index]
      temp_df_gc_jaccard$cut_point[cut_index] <- cuts[cut_index]
      if(measure == "Zscore" & only_brain){
        temp_df_gc$total[cut_index] <- length(grep("Brain",colnames(spec_mats[[el]]))) *
          nrow(spec_mats[[el]])
        temp_df_gc$gene_count[cut_index] <- length(which(
          spec_mats[[el]][,grep("Brain",colnames(spec_mats[[el]]),ignore.case = T)] >
            cuts[cut_index]))
        temp_df_gc_jaccard$jaccard[cut_index] <- 
        length(which(spec_mats[[el]][,grep("Brain",colnames(spec_mats[[el]]),ignore.case = T)] 
                     > cuts[cut_index] &
                       spec_mats[[el_pair]][,grep("Brain",colnames(spec_mats[[el]]),ignore.case = T)]
                     > cuts[cut_index] )) /
        length(which(spec_mats[[el]][,grep("Brain",colnames(spec_mats[[el]]),ignore.case = T)] >
                       cuts[cut_index] |
                       spec_mats[[el_pair]][,grep("Brain",colnames(spec_mats[[el]]),ignore.case = T)]
                     > cuts[cut_index] ))
      } else{
        temp_df_gc$gene_count[cut_index] <- length(which(spec_mats[[el]] > cuts[cut_index]))
        temp_df_gc_jaccard$jaccard[cut_index] <- 
        length(which(spec_mats[[el]] > cuts[cut_index] &
                       spec_mats[[el_pair]] > cuts[cut_index] )) /
        length(which(spec_mats[[el]] > cuts[cut_index] |
                       spec_mats[[el_pair]] > cuts[cut_index] ))
        
      }
      
    }
    df_gc <- rbind(df_gc, temp_df_gc)
    df_gc_jaccard <- rbind(df_gc_jaccard, temp_df_gc_jaccard)
  }
}

df_gc$brain[which(df_gc$measure != "Zscore")] <- F
df_gc_jaccard$brain[which(df_gc_jaccard$measure != "Zscore")] <- F
df_gc <- unique(df_gc)
df_gc_jaccard <- unique(df_gc_jaccard)


ggl_jacc_count <- list()
for(measure in c("Zscore", "notZscore")){
  if(measure == "Zscore"){
    which_count <- which(df_gc$measure == measure)
    which_jac <- which(df_gc_jaccard$measure == measure)
  } else {
    which_count <- which(df_gc$measure != "Zscore")
    which_jac <- which(df_gc_jaccard$measure != "Zscore")
  }
  gg <- ggplot(df_gc[which_count,],
               aes(x=cut_point, y=gene_count / total,
                   group=weighted))+
    theme_bw()+
    theme(
      panel.grid.minor.x = element_blank())+
    geom_line(aes(color=weighted))+
    scale_color_manual(values=c("grey20","steelblue3"))+
    scale_y_continuous( limits=c(1e-4,1) , trans = log10_trans(),
                       breaks = trans_breaks("log10", function(x) 10^x), # ) #,
                       labels = percent  )
  if(measure == "Zscore"){
    gg <- gg+scale_x_continuous(limits = c(0,4), breaks=seq(0,4,by=0.5), expand = c(0,0))
    gg <- gg + facet_grid(. ~ brain , labeller=labeller(brain=c("TRUE"="brain subset",
                                                                "FALSE"="all tissues")) )
    gg <- gg+theme(legend.position = "none")
  } else {
    gg <- gg + theme(axis.text.y = element_blank(), axis.title.y = element_blank())
    gg <- gg+scale_x_continuous(limits = c(0,1),  breaks=seq(0,1,by=0.1) ,expand = c(0,0))
    gg <- gg + facet_grid(. ~ measure )
  }
  plot(gg)
  ggl_jacc_count[[paste(measure,"_count",sep="")]] <- gg
  
  
  gg <- ggplot(df_gc_jaccard[which_jac,],
               aes(x=cut_point, y=jaccard))+
    theme_bw()+
    theme(
      panel.grid.minor.x = element_blank())+
    geom_line(aes(color="grey20"))+
    scale_color_manual(values=c("grey20"))+
    scale_y_continuous( limits=c(0,1),  breaks=seq(0,1,by=0.1) )
  if(measure == "Zscore"){
    gg <- gg+scale_x_continuous(limits = c(0,4), breaks=seq(0,4,by=0.5), expand = c(0,0))
    gg <- gg + facet_grid(. ~ brain , labeller=labeller(brain=c("TRUE"="brain subset",
                                                                "FALSE"="all tissues")) )
    gg <- gg+theme(legend.position = "none")
  } else {
    gg <- gg + theme(axis.text.y = element_blank(), axis.title.y = element_blank())
    gg <- gg+scale_x_continuous(limits = c(0,1),  breaks=seq(0,1,by=0.1) ,expand = c(0,0))
    gg <- gg + facet_grid(. ~ measure )
  }
  plot(gg)
  ggl_jacc_count[[paste(measure,"_jacc",sep="")]] <- gg
}


grobl <- list()
for(n in names(ggl_jacc_count)){
  grobl[[n]] <- ggplotGrob(ggl_jacc_count[[n]])
}

g <-  arrangeGrob(grobs =  list(grobl$Zscore_count, grobl$notZscore_count), ncol=2, widths=c(5,7))
filename <- paste(figures_dir,"/gtex_gene_count_supp.png",sep = "")
ggsave(filename, g, device = "png", width = 10, height = 4)

g <-  arrangeGrob(grobs =  list(grobl$Zscore_jacc, grobl$notZscore_jacc), ncol=2, widths=c(5,7))
filename <- paste(figures_dir,"/gtex_jac_supp.png",sep = "")
ggsave(filename, g, device = "png", width = 10, height = 4)







```

```{r Figure 3D}
## gene ontology summaries
library(DOSE)
library(pathview)
library(clusterProfiler)
library(org.Hs.eg.db)

library(tidyverse)
library(topGO) 
library(enrichplot)

spec_mat_weighted <- calc_weighted_zscore_matrix(exp_mat, weights = weights)
flat <- weights; flat[1:length(flat)] <- 1
spec_mat_flat  <- calc_weighted_zscore_matrix(exp_mat, flat)

cutoff <- 2
which <- which((spec_mat_weighted >= cutoff & spec_mat_flat < cutoff))

allOE_genes<-str_split_fixed(rownames(spec_mat_flat),"[.]",2)[,1]

sigOE_genes <- character()
for(j in 1:ncol(spec_mat_weighted)){
 which<-which((spec_mat_flat[,j]<=2.0 & spec_mat_weighted[,j]>=2.0))
which<-as.matrix(which)
  which<- rownames(which)
  which<-str_split_fixed(which, "[.]", 2)
  which<- which[,1]
   sigOE_genes <- c(sigOE_genes, which)
}
sigOE_genes<-unique(sigOE_genes)


for(onto in c("BP")){ #},"MF","CC")){
  print(onto)
  ego <- enrichGO(gene = sigOE_genes, 
                  universe = allOE_genes,
                  keyType = "ENSEMBL",
                  OrgDb = org.Hs.eg.db, 
                  ont = onto, 
                  pAdjustMethod = "BH",
                  qvalueCutoff = 0.05,
                  readable = TRUE,
                  pool=TRUE)

  
  n=10
  filename <- paste(figures_dir,"/",date,"_go_dot_",onto,"_",n,".png",sep = "")
  print(filename)
  #png(filename, width = 6, height = 10, units = "in", res=300 ) 
  print(dotplot(ego, showCategory = n))
  #dev.off()
  
  filename <- paste(figures_dir,"/",date,"_go_clus_wo_labels",onto,"_",n,".png",sep = "")
  print(filename)
  #png(filename, width = 8, height = 6, units = "in", res=300 )
  ego <- enrichplot::pairwise_termsim(ego)
  print(emapplot(ego, showCategory = n))
  #dev.off()
  
  filename <- paste(figures_dir,"/",date,"_go_graph_",onto,"_",n,".png",sep = "")
  print(filename)
  #png(filename, width = 6, height = 7, units = "in", res=300 ) 
  print(goplot(ego, showCategory = n)) ## note needed to nest goplot in print function for this to write to file.. not sure why
  #dev.off()
}

cluster_summary <- data.frame(ego)
cluster_summary$frac_terms <- as.numeric(str_split_fixed(cluster_summary$GeneRatio,"/",2)[,1] ) / as.numeric( str_split_fixed(cluster_summary$BgRatio,"/",2)[,1] )

```


```{r supplemental comparison of clustering methods}

## only 1 similarity function tested for now, can make as list later
similarity_func <- function(exp_mat){calc_dot_product_similarity_matrix(calc_zscore_matrix(exp_mat))}

## only 1 clustering fucntion tested for now, can make as a list later
cluster_func <- function(sim_mat, method="average"){
  add_weights(add_dist_to_parent(as.dendrogram(hclust(as.dist(1-sim_mat), method = method) ) ))
}


sim_mat <- similarity_func(exp_mat)
cluster_methods <- c("single","complete","average")
for(cm in cluster_methods){
  filename = paste(figures_dir,"/cluster_method_supp_",cm,".png",sep = "")
  #png(filename = filename, width=9, height=5, units="in", res=300)
  #par(mar = c(16,2,2,2))
  sim_tree <- cluster_func(sim_mat = sim_mat, method = cm)
  sim_tree %>% plot(main=cm)
 # dev.off()
}


```

```{r supplemental comparison of similarity measures}


### to do: justify method for measuring sample similarity - may require comparison or refs
calc_dot_product_similarity_matrix <- function(dat) {
  dot_product_similarity_matrix <- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  colnames(dot_product_similarity_matrix) <- colnames(dat)
  rownames(dot_product_similarity_matrix) <- colnames(dat)
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)){
      which_i <- which(!is.na(dat[,i])) ## ignore NAs
      which_j <- which(!is.na(dat[,j])) ## ignore NAs
      dot_product_similarity_matrix[i,j] <- sum(dat[which_i,i] * dat[which_j,j]) / (norm(dat[which_i,i],"2")*norm(dat[which_j,j],"2"))
    }
  }
  return(dot_product_similarity_matrix)
}
sim_mat<- (similarity_func(exp_mat))
sim_mat <- (sim_mat-min(sim_mat,na.rm=T)); sim_mat <- sim_mat/max(sim_mat,na.rm = T) ## coerce domain to [0-1]

hist(sim_mat)
sim_tree <- cluster_func(sim_mat)
filename = paste(figures_dir, "/sample_similarity_heatmap_cosine.png", sep="")
#png(filename = filename, width=10, height=10, units="in", res=300)
heatmap(sim_mat, Rowv = rev(sim_tree), Colv = sim_tree, scale = "none", margins=c(11,13))
#dev.off()


####ADDED
calc_eucl_matrix<- function(dat) {
  eucl<- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  colnames(eucl) <- colnames(dat)
  rownames(eucl) <- colnames(dat)
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)) {
       eucl[i,j]<-sqrt(sum((dat[,i]-dat[,j])^2,na.rm = T ) )
    }
  }
  return(eucl)
}
eucl_matrix<- 1-(calc_eucl_matrix(calc_zscore_matrix(exp_mat)))

eucl_matrix <- (eucl_matrix-min(eucl_matrix,na.rm=T)); eucl_matrix <- eucl_matrix/max(eucl_matrix,na.rm = T) ## coerce domain to [0-1]
hist(eucl_matrix)
sim_tree <- cluster_func(eucl_matrix)
filename = paste(figures_dir, "/sample_similarity_heatmap_eucl.png", sep="")
#png(filename = filename, width=10, height=10, units="in", res=300)
heatmap(eucl_matrix, Rowv = rev(sim_tree), Colv = sim_tree, scale = "none", margins=c(11,13))
#dev.off()

####ADDED
calc_manhattan_matrix<- function(dat) {
  manhatt<- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  colnames(manhatt) <- colnames(dat)
  rownames(manhatt) <- colnames(dat)
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)) {
       manhatt[i,j]<-sum(abs(dat[,i]-dat[,j]),na.rm = T)
    }
  }
  for(i in 1:nrow(manhatt)){
    manhatt[,i] <- manhatt[,i] / max(manhatt,na.rm=T )
  }  
  return(manhatt)
}
manhat_matrix<- 1-(calc_manhattan_matrix(calc_zscore_matrix(exp_mat)))

manhat_matrix <- (manhat_matrix-min(manhat_matrix,na.rm=T)); manhat_matrix <- manhat_matrix/max(manhat_matrix,na.rm = T) ## coerce domain to [0-1]
hist(manhat_matrix)
sim_tree <- cluster_func(manhat_matrix)
filename = paste(figures_dir, "/sample_similarity_heatmap_manhattan.png", sep="")
#png(filename = filename, width=10, height=10, units="in", res=300)
heatmap(manhat_matrix, Rowv = sim_tree, Colv = rev(sim_tree), scale = "none", margins=c(11,13))
#dev.off()

calc_canberra_matrix<- function(dat) {
  canberra<- matrix(0, nrow = ncol(dat), ncol = ncol(dat))
  colnames(canberra) <- colnames(dat)
  rownames(canberra) <- colnames(dat)
  for(i in 1:ncol(dat)){
    for(j in 1:ncol(dat)) {
      canberra[i,j]<- sum(abs(dat[,i] - dat[,j])/ (abs(dat[,i])+abs(dat[,j])) , na.rm = T) 
    }
  }
  for(i in 1:nrow(canberra)){
    canberra[,i] <- canberra[,i] / max(canberra,na.rm=T )
  }  
  return(canberra)
}

canberra_mat<- 1-(calc_canberra_matrix( calc_zscore_matrix(exp_mat)))
canberra_mat <- (canberra_mat-min(canberra_mat,na.rm=T)); canberra_mat <- canberra_mat/max(canberra_mat,na.rm = T) ## coerce domain to [0-1]
hist(canberra_mat)
sim_tree <- cluster_func(canberra_mat)
filename = paste(figures_dir, "/sample_similarity_heatmap_canberra.png", sep="")
#png(filename = filename, width=10, height=10, units="in", res=300)
heatmap(canberra_mat, Rowv = sim_tree, Colv = rev(sim_tree), scale = "none", margins=c(11,13))
#dev.off()



```



